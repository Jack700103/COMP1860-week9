// ================================================
// Crossing Controller with Pedestrian Timer
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:

    // --- State Registers ---
    // 使用3位状态机: 000-111表示8个状态
    // 状态分配:
    // 000: X红 (初始状态)
    // 001: X红黄
    // 010: X绿
    // 011: X黄
    // 100: Z红
    // 101: Z红黄
    // 110: Z绿
    // 111: Z黄
    
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // 创建反相信号
    Not(in=S0, out=notS0);
    Not(in=S1, out=notS1);
    Not(in=S2, out=notS2);
    
    // --- Timer Register (4 bits for 9-0 countdown) ---
    DFF(in=nextTimer3, out=Timer3);
    DFF(in=nextTimer2, out=Timer2);
    DFF(in=nextTimer1, out=Timer1);
    DFF(in=nextTimer0, out=Timer0);
    
    // 创建反相信号
    Not(in=Timer0, out=notTimer0);
    Not(in=Timer1, out=notTimer1);
    Not(in=Timer2, out=notTimer2);
    Not(in=Timer3, out=notTimer3);
    
    // --- Button Press Logic ---
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRisingEdge);
    
    // ButtonPressed寄存器
    DFF(in=nextBP, out=ButtonPressedReg);
    
    // 按钮按下时设置，计时器结束时清除
    // 计时器结束条件：计时器值为0 (0000)
    And(a=notTimer3, b=notTimer2, out=andT32);
    And(a=notTimer1, b=notTimer0, out=andT10);
    And(a=andT32, b=andT10, out=timerZero);
    
    // 当按钮按下或已有按钮按下且计时器未结束时，保持按钮按下状态
    Or(a=ButtonRisingEdge, b=ButtonPressedReg, out=bpOr);
    And(a=bpOr, b=timerZero, out=bpAndNotZero);
    Not(in=timerZero, out=notTimerZero);
    And(a=ButtonPressedReg, b=notTimerZero, out=bpKeep);
    Or(a=ButtonRisingEdge, b=bpKeep, out=nextBPtemp);
    And(a=nextBPtemp, b=PowerOn, out=nextBP);
    
    // 最终ButtonPressed输出
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
    
    // --- Timer Mode Detection ---
    // 当按钮按下且处于同步点（两个灯都红）时进入计时模式
    // 同步点：当从Z黄回到X红时，状态111->000
    
    // 检查是否是状态111（Z黄）
    And(a=S2, b=S1, out=andS21);
    And(a=andS21, b=S0, out=state111);
    
    // 检查是否是状态000（X红）
    And(a=notS2, b=notS1, out=andNotS21);
    And(a=andNotS21, b=notS0, out=state000);
    
    // 计时器模式触发器
    DFF(in=nextTimerMode, out=TimerMode);
    
    // 进入计时模式条件：按钮已按下且在状态111
    And(a=ButtonPressedReg, b=state111, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);
    
    // 退出计时模式条件：计时器为0
    And(a=TimerMode, b=timerZero, out=exitTimer);
    
    // 下一计时器模式状态
    Or(a=TimerMode, b=enterTimer, out=stayOrEnter);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrEnter, b=notExit, out=nextTimerMode);
    
    // Wait信号：计时模式时为0，否则为1
    Not(in=TimerMode, out=Wait);
    
    // --- Normal State Transition Logic ---
    // 正常状态转换（与JunctionController类似）
    Not(in=S0, out=notS0temp);
    Xor(a=S1, b=S0, out=xorS1S0);
    And(a=S1, b=S0, out=andS1S0);
    Xor(a=S2, b=andS1S0, out=xorS2);
    
    // 正常下一状态
    Mux(a=false, b=xorS2, sel=PowerOn, out=nextS2Normal);
    Mux(a=false, b=xorS1S0, sel=PowerOn, out=nextS1Normal);
    Mux(a=false, b=notS0temp, sel=PowerOn, out=nextS0Normal);
    
    // 计时模式时保持状态不变，否则正常转换
    Mux(a=nextS2Normal, b=S2, sel=TimerMode, out=nextS2);
    Mux(a=nextS1Normal, b=S1, sel=TimerMode, out=nextS1);
    Mux(a=nextS0Normal, b=S0, sel=TimerMode, out=nextS0);
    
    // --- Timer Counter Logic ---
    // 4位递减计数器，从9(1001)到0(0000)
    
    // 创建4位递减器（减1）
    // 使用全加器加1111来实现减1
    FullAdder(a=Timer0, b=true, c=false, sum=dec0, carry=carry0);
    FullAdder(a=Timer1, b=true, c=carry0, sum=dec1, carry=carry1);
    FullAdder(a=Timer2, b=true, c=carry1, sum=dec2, carry=carry2);
    FullAdder(a=Timer3, b=true, c=carry2, sum=dec3, carry=carry3);
    
    // 选择下一个计时器值
    And(a=TimerMode, b=notTimerZero, out=decrement);
    
    // 进入计时模式时加载9，否则递减或保持
    Mux(a=Timer3, b=dec3, sel=decrement, out=nextTimer3Temp);
    Mux(a=nextTimer3Temp, b=true, sel=enterTimer, out=nextTimer3);
    
    Mux(a=Timer2, b=dec2, sel=decrement, out=nextTimer2Temp);
    Mux(a=nextTimer2Temp, b=false, sel=enterTimer, out=nextTimer2);
    
    Mux(a=Timer1, b=dec1, sel=decrement, out=nextTimer1Temp);
    Mux(a=nextTimer1Temp, b=false, sel=enterTimer, out=nextTimer1);
    
    Mux(a=Timer0, b=dec0, sel=decrement, out=nextTimer0Temp);
    Mux(a=nextTimer0Temp, b=true, sel=enterTimer, out=nextTimer0);
    
    // --- Traffic Light Output Logic ---
    // 根据状态输出交通灯信号
    // X[2]=红, X[1]=黄, X[0]=绿
    // Z[2]=红, Z[1]=黄, Z[0]=绿
    
    // 正常模式下的X灯
    // 状态000: X红 (100)
    And(a=notS2, b=notS1, out=state00x);
    And(a=state00x, b=notS0, out=state000real);
    
    // 状态001: X红黄 (110)
    And(a=notS2, b=notS1, out=state00x2);
    And(a=state00x2, b=S0, out=state001);
    
    // 状态010: X绿 (001)
    And(a=notS2, b=S1, out=state01x);
    And(a=state01x, b=notS0, out=state010);
    
    // 状态011: X黄 (010)
    And(a=notS2, b=S1, out=state01x2);
    And(a=state01x2, b=S0, out=state011);
    
    // 正常模式下的Z灯
    // 状态100: Z红 (100)
    And(a=S2, b=notS1, out=state10x);
    And(a=state10x, b=notS0, out=state100);
    
    // 状态101: Z红黄 (110)
    And(a=S2, b=notS1, out=state10x2);
    And(a=state10x2, b=S0, out=state101);
    
    // 状态110: Z绿 (001)
    And(a=S2, b=S1, out=state11x);
    And(a=state11x, b=notS0, out=state110);
    
    // 状态111: Z黄 (010)
    And(a=S2, b=S1, out=state11x2);
    And(a=state11x2, b=S0, out=state111real);
    
    // X灯输出
    Mux(a=false, b=true, sel=state000real, out=Xrednormal);
    Mux(a=false, b=true, sel=state001, out=Xrednormal2);
    Or(a=Xrednormal, b=Xrednormal2, out=Xrednormalor);
    Mux(a=false, b=false, sel=state010, out=Xrednormal3);
    Or(a=Xrednormalor, b=Xrednormal3, out=Xrednormalfinal);
    
    Mux(a=false, b=true, sel=state001, out=Xambernormal);
    Mux(a=false, b=true, sel=state011, out=Xambernormal2);
    Or(a=Xambernormal, b=Xambernormal2, out=Xambernormalfinal);
    
    Mux(a=false, b=true, sel=state010, out=Xgreennormal);
    
    // Z灯输出
    Mux(a=false, b=true, sel=state100, out=Zrednormal);
    Mux(a=false, b=true, sel=state101, out=Zrednormal2);
    Or(a=Zrednormal, b=Zrednormal2, out=Zrednormalor);
    Mux(a=false, b=false, sel=state110, out=Zrednormal3);
    Or(a=Zrednormalor, b=Zrednormal3, out=Zrednormalfinal);
    
    Mux(a=false, b=true, sel=state101, out=Zambernormal);
    Mux(a=false, b=true, sel=state111real, out=Zambernormal2);
    Or(a=Zambernormal, b=Zambernormal2, out=Zambernormalfinal);
    
    Mux(a=false, b=true, sel=state110, out=Zgreennormal);
    
    // 应用计时模式覆盖：计时模式下，两个灯都是红
    Mux(a=Xrednormalfinal, b=true, sel=TimerMode, out=X[2]);
    Mux(a=Xambernormalfinal, b=false, sel=TimerMode, out=X[1]);
    Mux(a=Xgreennormal, b=false, sel=TimerMode, out=X[0]);
    
    Mux(a=Zrednormalfinal, b=true, sel=TimerMode, out=Z[2]);
    Mux(a=Zambernormalfinal, b=false, sel=TimerMode, out=Z[1]);
    Mux(a=Zgreennormal, b=false, sel=TimerMode, out=Z[0]);
    
    // --- 7-Segment Display Decoder ---
    // 根据8.jpg: 段位排列为:
    //    e
    //  d   f
    //    b
    //  g   c
    //    a
    // C[6..0] = a, b, c, d, e, f, g
    
    // 简单的查找表方式实现0-9的7段显示
    // 使用Mux16实现4位输入到7位输出的查找表
    
    // 由于HDL中没有Mux16，我们使用多个Mux4way16来实现
    // 首先将7位输出分成两组，但这样很复杂
    
    // 简化：直接为每个数字实现逻辑
    
    // 数字0: 1111110
    And(a=notTimer3, b=notTimer2, out=digit0cond1);
    And(a=digit0cond1, b=notTimer1, out=digit0cond2);
    And(a=digit0cond2, b=notTimer0, out=digit0);
    
    // 数字1: 0110000
    And(a=notTimer3, b=notTimer2, out=digit1cond1);
    And(a=digit1cond1, b=notTimer1, out=digit1cond2);
    And(a=digit1cond2, b=Timer0, out=digit1);
    
    // 数字2: 1101101
    And(a=notTimer3, b=notTimer2, out=digit2cond1);
    And(a=digit2cond1, b=Timer1, out=digit2cond2);
    And(a=digit2cond2, b=notTimer0, out=digit2);
    
    // 数字3: 1111001
    And(a=notTimer3, b=notTimer2, out=digit3cond1);
    And(a=digit3cond1, b=Timer1, out=digit3cond2);
    And(a=digit3cond2, b=Timer0, out=digit3);
    
    // 数字4: 0110011
    And(a=notTimer3, b=Timer2, out=digit4cond1);
    And(a=digit4cond1, b=notTimer1, out=digit4cond2);
    And(a=digit4cond2, b=notTimer0, out=digit4);
    
    // 数字5: 1011011
    And(a=notTimer3, b=Timer2, out=digit5cond1);
    And(a=digit5cond1, b=notTimer1, out=digit5cond2);
    And(a=digit5cond2, b=Timer0, out=digit5);
    
    // 数字6: 1011111
    And(a=notTimer3, b=Timer2, out=digit6cond1);
    And(a=digit6cond1, b=Timer1, out=digit6cond2);
    And(a=digit6cond2, b=notTimer0, out=digit6);
    
    // 数字7: 1110000
    And(a=notTimer3, b=Timer2, out=digit7cond1);
    And(a=digit7cond1, b=Timer1, out=digit7cond2);
    And(a=digit7cond2, b=Timer0, out=digit7);
    
    // 数字8: 1111111
    And(a=Timer3, b=notTimer2, out=digit8cond1);
    And(a=digit8cond1, b=notTimer1, out=digit8cond2);
    And(a=digit8cond2, b=notTimer0, out=digit8);
    
    // 数字9: 1111011
    And(a=Timer3, b=notTimer2, out=digit9cond1);
    And(a=digit9cond1, b=notTimer1, out=digit9cond2);
    And(a=digit9cond2, b=Timer0, out=digit9);
    
    // 段a (C[6]) 逻辑
    Or(a=digit0, b=digit2, out=ora1);
    Or(a=ora1, b=digit3, out=ora2);
    Or(a=ora2, b=digit5, out=ora3);
    Or(a=ora3, b=digit6, out=ora4);
    Or(a=ora4, b=digit7, out=ora5);
    Or(a=ora5, b=digit8, out=ora6);
    Or(a=ora6, b=digit9, out=segAraw);
    And(a=segAraw, b=TimerMode, out=C[6]);
    
    // 段b (C[5]) 逻辑
    Or(a=digit0, b=digit1, out=orb1);
    Or(a=orb1, b=digit2, out=orb2);
    Or(a=orb2, b=digit3, out=orb3);
    Or(a=orb3, b=digit4, out=orb4);
    Or(a=orb4, b=digit7, out=orb5);
    Or(a=orb5, b=digit8, out=orb6);
    Or(a=orb6, b=digit9, out=segBraw);
    And(a=segBraw, b=TimerMode, out=C[5]);
    
    // 段c (C[4]) 逻辑
    Or(a=digit0, b=digit1, out=orc1);
    Or(a=orc1, b=digit3, out=orc2);
    Or(a=orc2, b=digit4, out=orc3);
    Or(a=orc3, b=digit5, out=orc4);
    Or(a=orc4, b=digit6, out=orc5);
    Or(a=orc5, b=digit7, out=orc6);
    Or(a=orc6, b=digit8, out=orc7);
    Or(a=orc7, b=digit9, out=segCraw);
    And(a=segCraw, b=TimerMode, out=C[4]);
    
    // 段d (C[3]) 逻辑
    Or(a=digit0, b=digit2, out=ord1);
    Or(a=ord1, b=digit3, out=ord2);
    Or(a=ord2, b=digit5, out=ord3);
    Or(a=ord3, b=digit6, out=ord4);
    Or(a=ord4, b=digit8, out=ord5);
    Or(a=ord5, b=digit9, out=segDraw);
    And(a=segDraw, b=TimerMode, out=C[3]);
    
    // 段e (C[2]) 逻辑
    Or(a=digit0, b=digit2, out=ore1);
    Or(a=ore1, b=digit6, out=ore2);
    Or(a=ore2, b=digit8, out=segEraw);
    And(a=segEraw, b=TimerMode, out=C[2]);
    
    // 段f (C[1]) 逻辑
    Or(a=digit0, b=digit4, out=orf1);
    Or(a=orf1, b=digit5, out=orf2);
    Or(a=orf2, b=digit6, out=orf3);
    Or(a=orf3, b=digit8, out=orf4);
    Or(a=orf4, b=digit9, out=segFraw);
    And(a=segFraw, b=TimerMode, out=C[1]);
    
    // 段g (C[0]) 逻辑
    Or(a=digit2, b=digit3, out=org1);
    Or(a=org1, b=digit4, out=org2);
    Or(a=org2, b=digit5, out=org3);
    Or(a=org3, b=digit6, out=org4);
    Or(a=org4, b=digit8, out=org5);
    Or(a=org5, b=digit9, out=segGraw);
    And(a=segGraw, b=TimerMode, out=C[0]);
    
    // 非计时模式下，7段数码管全灭
    // 上面已经通过And(a=..., b=TimerMode)实现了
}