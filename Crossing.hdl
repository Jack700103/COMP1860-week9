CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    DFF(in=nexts0, out=s0);
    DFF(in=nexts1, out=s1);

    DFF(in=nextbuttonFlag, out=buttonFlag);

    Not(in=s0, out=nots0);
    Not(in=s1, out=nots1);
    And(a=nots0, b=nots1, out=state0);  
    And(a=s0, b=nots1, out=state1);     
    And(a=nots0, b=s1, out=state2);     

    // 在JunctionController调用处拆分总线
    JunctionController(PowerOn=PowerOn, X[0]=Xjunc0, X[1]=Xjunc1, X[2]=Xjunc2,
                       Z[0]=Zjunc0, Z[1]=Zjunc1, Z[2]=Zjunc2);
 
    // 使用拆分后的单独线路连接DFF
    DFF(in=Xjunc0, out=Xtemp0);
    DFF(in=Xjunc1, out=Xtemp1);
    DFF(in=Xjunc2, out=Xtemp2);

    DFF(in=Zjunc0, out=Ztemp0);
    DFF(in=Zjunc1, out=Ztemp1);
    DFF(in=Zjunc2, out=Ztemp2);

    Not(in=Xtemp1, out=notXtemp1);
    Not(in=Xtemp0, out=notXtemp0);
    And(a=Xtemp2, b=notXtemp1, out=XisRedpart);
    And(a=XisRedpart, b=notXtemp0, out=XisRed);

    Not(in=Ztemp1, out=notZtemp1);
    Not(in=Ztemp0, out=notZtemp0);
    And(a=Ztemp2, b=notZtemp1, out=ZisRedpart);
    And(a=ZisRedpart, b=notZtemp0, out=ZisRed);

    And(a=XisRed, b=ZisRed, out=cycleComplete);

    And(a=state0, b=Button, out=setButtonFlag);
    And(a=state2, b=timerDone, out=clearButtonFlag);

    Or(a=setButtonFlag, b=buttonFlag, out=buttonFlagbeforeclear);

    Not(in=clearButtonFlag, out=notclearButtonFlag);
    And(a=buttonFlagbeforeclear, b=notclearButtonFlag, out=buttonFlagtemp);

    Not(in=PowerOn, out=notPowerOn);
    Mux(a=buttonFlagtemp, b=false, sel=notPowerOn, out=nextbuttonFlag);

    Or(a=buttonFlag, b=false, out=ButtonPressed);

    // Wait信号只在state1时为1
    Or(a=state1, b=false, out=Wait);

    // X和Z输出：state2时固定为100，否则为交通灯状态
    Mux(a=Xtemp0, b=false, sel=state2, out=X[0]);
    Mux(a=Xtemp1, b=false, sel=state2, out=X[1]);
    Mux(a=Xtemp2, b=true,  sel=state2, out=X[2]);

    Mux(a=Ztemp0, b=false, sel=state2, out=Z[0]);
    Mux(a=Ztemp1, b=false, sel=state2, out=Z[1]);
    Mux(a=Ztemp2, b=true,  sel=state2, out=Z[2]);

    Not(in=state2, out=notstate2);
    Or(a=notPowerOn, b=notstate2, out=timerReset);

    // 计数器：在state2时递减，其他状态复位
    CounterDec(dec=state2, reset=timerReset, out[0]=count0, out[1]=count1, out[2]=count2, out[3]=count3);
    
    // 检测计数器是否为零（4位全为0）
    Or(a=count0, b=count1, out=anyBit01);
    Or(a=count2, b=count3, out=anyBit23);
    Or(a=anyBit01, b=anyBit23, out=anyBitSet);
    Not(in=anyBitSet, out=timerDone);

    // 七段显示：只在state2时显示计数器值，其他状态显示0
    DisplayCounter(dec=state2, reset=timerReset, a=dispa, b=dispb, c=dispc, d=dispd, e=dispe, f=dispf, g=dispg);
    
    Mux(a=dispa, b=false, sel=state2, out=C[0]);
    Mux(a=dispb, b=false, sel=state2, out=C[1]);
    Mux(a=dispc, b=false, sel=state2, out=C[2]);
    Mux(a=dispd, b=false, sel=state2, out=C[3]);
    Mux(a=dispe, b=false, sel=state2, out=C[4]);
    Mux(a=dispf, b=false, sel=state2, out=C[5]);
    Mux(a=dispg, b=false, sel=state2, out=C[6]);

    // 状态转换逻辑
    And(a=state0, b=buttonFlag, out=condition0to1);
    And(a=state0, b=condition0to1, out=tostate1);
    Not(in=cycleComplete, out=notcycleComplete);
    And(a=state1, b=notcycleComplete, out=staystate1);
    Or(a=tostate1, b=staystate1, out=nexts0temp);

    And(a=state1, b=cycleComplete, out=tostate2);
    Not(in=timerDone, out=nottimerDone);
    And(a=state2, b=nottimerDone, out=staystate2);
    Or(a=tostate2, b=staystate2, out=nexts1temp);

    // 修改：复位时进入state1（s0=1, s1=0），符合测试输出
    Mux(a=nexts0temp, b=true, sel=notPowerOn, out=nexts0);
    Mux(a=nexts1temp, b=false, sel=notPowerOn, out=nexts1);
}