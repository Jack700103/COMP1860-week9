CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:

    //=====================
    // state register s1 s0
    // 00 idle
    // 01 wait (button pressed, waiting for both red)
    // 10 count (pedestrian countdown)
    //=====================

    DFF(in=nextS0, out=s0);
    DFF(in=nextS1, out=s1);

    Not(in=s0, out=ns0);
    Not(in=s1, out=ns1);

    And(a=ns1, b=ns0, out=idle);     //00
    And(a=ns1, b=s0,  out=wait);     //01
    And(a=s1,  b=ns0, out=count);    //10

    // Wait output
    Or(a=wait, b=false, out=Wait);

    //=====================
    // Call junction controller
    //=====================
    JunctionController(
        PowerOn=PowerOn,
        X[0]=jx0, X[1]=jx1, X[2]=jx2,
        Z[0]=jz0, Z[1]=jz1, Z[2]=jz2
    );

    //=====================
    // detect both red
    //=====================

    // X red = 100
    Not(in=jx0, out=njx0);
    Not(in=jx1, out=njx1);
    And(a=jx2, b=njx1, out=t1x);
    And(a=t1x, b=njx0, out=xred);

    // Z red = 100
    Not(in=jz0, out=njz0);
    Not(in=jz1, out=njz1);
    And(a=jz2, b=njz1, out=t1z);
    And(a=t1z, b=njz0, out=zred);

    And(a=xred, b=zred, out=bothred);

    //=====================
    // button flag
    //=====================
    DFF(in=nextFlag, out=flag);

    // set flag whenever Button is pressed
    Or(a=Button, b=false, out=setF);

    // clear flag only after countdown ends
    And(a=count, b=timerDone, out=clrF);
    Not(in=clrF, out=nclrF);

    And(a=flag, b=nclrF, out=holdF);
    Or(a=setF, b=holdF, out=flagMid);

    // PowerOn=0 resets flag
    Mux(a=false, b=flagMid, sel=PowerOn, out=nextFlag);

    Or(a=flag, b=false, out=ButtonPressed);

    //=====================
    // next state logic
    //=====================

    // idle → wait
    And(a=idle, b=flag, out=g1);

    // wait → wait
    Not(in=bothred, out=nbothred);
    And(a=wait, b=nbothred, out=g2);

    // wait → count
    And(a=wait, b=bothred, out=g3);

    // count → count
    Not(in=timerDone, out=ntd);
    And(a=count, b=ntd, out=g4);

    // next s0
    Or(a=g1, b=g2, out=nxt0);
    // next s1
    Or(a=g3, b=g4, out=nxt1);

    Mux(a=false, b=nxt0, sel=PowerOn, out=nextS0);
    Mux(a=false, b=nxt1, sel=PowerOn, out=nextS1);

    //=====================
    // countdown timer
    //=====================
    Not(in=count, out=ncount);
    Or(a=ncount, b=NotPowerOn, out=resetTimer);

    CounterDec(
        dec=count,
        reset=resetTimer,
        out[0]=c0, out[1]=c1, out[2]=c2, out[3]=c3
    );

    Or(a=c0, b=c1, out=t01);
    Or(a=c2, b=c3, out=t23);
    Or(a=t01, b=t23, out=any);
    Not(in=any, out=timerDone);

    Decoder(in[0]=c0, in[1]=c1, in[2]=c2, in[3]=c3,
            a=da, b=db, c=dc, d=dd, e=de, f=df, g=dg);

    // only show digits in count state
    Mux(a=da, b=false, sel=count, out=C[0]);
    Mux(a=db, b=false, sel=count, out=C[1]);
    Mux(a=dc, b=false, sel=count, out=C[2]);
    Mux(a=dd, b=false, sel=count, out=C[3]);
    Mux(a=de, b=false, sel=count, out=C[4]);
    Mux(a=df, b=false, sel=count, out=C[5]);
    Mux(a=dg, b=false, sel=count, out=C[6]);

    //=====================================
    // vehicle signals: normal except in count
    //=====================================
    Mux(a=jx0, b=false, sel=count, out=X[0]);
    Mux(a=jx1, b=false, sel=count, out=X[1]);
    Mux(a=jx2, b=true,  sel=count, out=X[2]);

    Mux(a=jz0, b=false, sel=count, out=Z[0]);
    Mux(a=jz1, b=false, sel=count, out=Z[1]);
    Mux(a=jz2, b=true,  sel=count, out=Z[2]);
}
