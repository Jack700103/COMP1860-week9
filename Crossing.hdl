// ================================================
// Crossing Controller with Pedestrian Timer
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    
    // --- 状态寄存器 ---
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // 反相信号
    Not(in=S0, out=notS0);
    Not(in=S1, out=notS1);
    Not(in=S2, out=notS2);
    
    // --- 状态转移逻辑 ---
    Xor(a=S1, b=S0, out=xorS1S0);
    And(a=S1, b=S0, out=andS1S0);
    Xor(a=S2, b=andS1S0, out=xorS2);
    
    // 正常模式下的下一状态
    Mux(a=false, b=xorS2, sel=PowerOn, out=nextS2normal);
    Mux(a=false, b=xorS1S0, sel=PowerOn, out=nextS1normal);
    Mux(a=false, b=notS0, sel=PowerOn, out=nextS0normal);
    
    // --- 计时器模式控制 ---
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // --- 按钮检测逻辑 ---
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRisingEdge);
    
    // ButtonPressed寄存器
    DFF(in=nextBP, out=ButtonPressedReg);
    
    // --- 计时器模块 ---
    // 将CounterDec的4位输出分别连接到单个位信号
    CounterDec(dec=TimerDec, reset=TimerReset, out=Timer0, out=Timer1, out=Timer2, out=Timer3);
    
    // 检查计时器是否为0（0000）
    Or(a=Timer0, b=Timer1, out=or01);
    Or(a=Timer2, b=Timer3, out=or23);
    Or(a=or01, b=or23, out=TimerNotZero);
    Not(in=TimerNotZero, out=TimerZero);
    
    // --- 检测Z周期完成 ---
    DFF(in=S2, out=S2prev);
    And(a=S2prev, b=notS2, out=S2falling);
    
    // 计时器启动条件：按钮已按下且Z周期完成
    And(a=ButtonPressedReg, b=S2falling, out=startTimerCond);
    And(a=startTimerCond, b=PowerOn, out=startTimer);
    
    // --- 按钮锁存逻辑 ---
    Or(a=ButtonRisingEdge, b=ButtonPressedReg, out=BPor);
    And(a=BPor, b=notTimerMode, out=BPand);
    Or(a=BPand, b=ButtonRisingEdge, out=nextBPtemp);
    And(a=nextBPtemp, b=PowerOn, out=nextBP);
    
    // --- 计时器模式控制逻辑 ---
    And(a=TimerMode, b=TimerZero, out=exitTimer);
    Or(a=TimerMode, b=startTimer, out=stayOrStart);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrStart, b=notExit, out=nextTimerMode);
    
    // 计时器递减使能：计时器模式且计时器不为0
    And(a=TimerMode, b=TimerNotZero, out=TimerDec);
    
    // 计时器复位：启动计时器时复位到9
    Mux(a=false, b=true, sel=startTimer, out=TimerReset);
    
    // --- 应用计时器模式到状态转移 ---
    Mux(a=nextS2normal, b=S2, sel=TimerMode, out=nextS2);
    Mux(a=nextS1normal, b=S1, sel=TimerMode, out=nextS1);
    Mux(a=nextS0normal, b=S0, sel=TimerMode, out=nextS0);
    
    // --- 交通灯输出逻辑 ---
    Mux(a=S1, b=false, sel=S2, out=xstate1);
    Mux(a=S0, b=false, sel=S2, out=xstate0);
    
    Mux(a=false, b=S1, sel=S2, out=zstate1);
    Mux(a=false, b=S0, sel=S2, out=zstate0);
    
    // X灯输出
    Not(in=xstate1, out=Xrednormal);
    Or(a=xstate0, b=false, out=Xambernormal);
    Not(in=xstate0, out=notxstate0);
    And(a=xstate1, b=notxstate0, out=Xgreennormal);
    
    // Z灯输出
    Not(in=zstate1, out=Zrednormal);
    Or(a=zstate0, b=false, out=Zambernormal);
    Not(in=zstate0, out=notzstate0);
    And(a=zstate1, b=notzstate0, out=Zgreennormal);
    
    // 应用计时器模式覆盖
    Mux(a=Xrednormal, b=true, sel=TimerMode, out=X[2]);
    Mux(a=Xambernormal, b=false, sel=TimerMode, out=X[1]);
    Mux(a=Xgreennormal, b=false, sel=TimerMode, out=X[0]);
    
    Mux(a=Zrednormal, b=true, sel=TimerMode, out=Z[2]);
    Mux(a=Zambernormal, b=false, sel=TimerMode, out=Z[1]);
    Mux(a=Zgreennormal, b=false, sel=TimerMode, out=Z[0]);
    
    // --- Wait信号 ---
    Not(in=TimerMode, out=Wait);
    
    // --- 7段数码管输出 ---
    // 将计时器的4个位信号组合成一个4位总线作为Decoder的输入
    // 创建4位总线：使用Or门将单bit信号与false连接，创建总线位
    Or(a=Timer0, b=false, out=DecIn0);
    Or(a=Timer1, b=false, out=DecIn1);
    Or(a=Timer2, b=false, out=DecIn2);
    Or(a=Timer3, b=false, out=DecIn3);
    
    // 将4个单bit信号组合成4位总线
    // 注意：这里我们使用多个Or门创建总线，但实际上HDL可能不支持这样创建总线
    // 我们需要换一种方式：使用4个单bit信号作为Decoder的输入
    
    // 方法：直接使用4个单bit信号，不创建总线
    // 但Decoder期望一个4位输入，所以我们需要创建临时的4位信号
    // 使用Or门将每个计时器位连接到对应的总线位
    
    // 创建临时的4位总线节点
    // 注意：在HDL中我们不能直接创建总线，但我们可以将每个位单独传递
    
    // 由于Decoder需要一个4位输入，我们需要一种方法将4个单bit信号组合
    // 在Nand2Tetris中，我们可以这样处理：创建一个临时芯片来包装这些信号
    // 但这里我们简化：直接使用单bit信号，并在Decoder内部处理
    
    // 然而，我们已有的Decoder芯片期望一个4位输入，所以我们需要调整
    
    // 方法：创建一个临时的4位总线，使用Or门
    // 创建4位总线信号
    Or(a=Timer0, b=false, out=bus0);
    Or(a=Timer1, b=false, out=bus1);
    Or(a=Timer2, b=false, out=bus2);
    Or(a=Timer3, b=false, out=bus3);
    
    // 现在使用这些信号作为Decoder的输入
    // 我们需要将4个单bit信号作为4位总线传递给Decoder
    // 在HDL中，我们可以这样写：
    // Decoder(in[0]=bus0, in[1]=bus1, in[2]=bus2, in[3]=bus3, ...)
    
    // 创建4位输入数组
    // 注意：在Nand2Tetris HDL中，我们需要使用正确的语法
    
    // 实际上，我们可以这样调用Decoder：
    Decoder(in[0]=bus0, in[1]=bus1, in[2]=bus2, in[3]=bus3, 
            a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG);
    
    // 仅当计时器模式时输出数码管信号
    And(a=segA, b=TimerMode, out=C[6]);
    And(a=segB, b=TimerMode, out=C[5]);
    And(a=segC, b=TimerMode, out=C[4]);
    And(a=segD, b=TimerMode, out=C[3]);
    And(a=segE, b=TimerMode, out=C[2]);
    And(a=segF, b=TimerMode, out=C[1]);
    And(a=segG, b=TimerMode, out=C[0]);
    
    // --- ButtonPressed输出 ---
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
}