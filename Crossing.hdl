// ================================================
// Crossing Controller with Pedestrian Timer
// 完全重构版本 - 确保每个输出只有一个驱动源
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    
    // --- 时钟分频器（简化） ---
    // 使用DFF创建分频时钟
    DFF(in=clkDiv0, out=clk0);
    Not(in=clk0, out=notClk0);
    And(a=PowerOn, b=notClk0, out=clkDiv0);
    
    // --- 状态寄存器 (3位) ---
    // 状态编码: 
    // 000: X红, Z红 (初始)
    // 001: X红黄, Z红
    // 010: X绿, Z红  
    // 011: X黄, Z红
    // 100: X红, Z红黄
    // 101: X红, Z绿
    // 110: X红, Z黄
    // 111: 计时器模式
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 状态反相信号
    Not(in=state0, out=notState0);
    Not(in=state1, out=notState1);
    Not(in=state2, out=notState2);
    
    // --- 状态解码 ---
    // 状态000: X红, Z红
    And(a=notState2, b=notState1, out=and0001);
    And(a=and0001, b=notState0, out=state000);
    
    // 状态001: X红黄, Z红
    And(a=notState2, b=notState1, out=and0011);
    And(a=and0011, b=state0, out=state001);
    
    // 状态010: X绿, Z红
    And(a=notState2, b=state1, out=and0101);
    And(a=and0101, b=notState0, out=state010);
    
    // 状态011: X黄, Z红
    And(a=notState2, b=state1, out=and0111);
    And(a=and0111, b=state0, out=state011);
    
    // 状态100: X红, Z红黄
    And(a=state2, b=notState1, out=and1001);
    And(a=and1001, b=notState0, out=state100);
    
    // 状态101: X红, Z绿
    And(a=state2, b=notState1, out=and1011);
    And(a=and1011, b=state0, out=state101);
    
    // 状态110: X红, Z黄
    And(a=state2, b=state1, out=and1101);
    And(a=and1101, b=notState0, out=state110);
    
    // 状态111: 计时器模式
    And(a=state2, b=state1, out=and1111);
    And(a=and1111, b=state0, out=state111);
    
    // --- 计时器模式寄存器 ---
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // --- 按钮检测和锁存 ---
    DFF(in=Button, out=buttonPrev);
    Not(in=buttonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=buttonRisingEdge);
    
    // 按钮锁存寄存器
    DFF(in=nextButtonLatched, out=buttonLatched);
    
    // --- 计时器模块 ---
    // 使用4位寄存器作为计时器
    DFF(in=nextTimer0, out=timer0);
    DFF(in=nextTimer1, out=timer1);
    DFF(in=nextTimer2, out=timer2);
    DFF(in=nextTimer3, out=timer3);
    
    // 检测计时器是否为0 (0000)
    Or(a=timer0, b=timer1, out=orTimer01);
    Or(a=timer2, b=timer3, out=orTimer23);
    Or(a=orTimer01, b=orTimer23, out=timerNotZero);
    Not(in=timerNotZero, out=timerZero);
    
    // --- 计时器递减逻辑 ---
    // 位0取反
    Not(in=timer0, out=notTimer0);
    
    // 计算进位
    And(a=timerDec, b=timer0, out=carry0);
    
    Xor(a=timer1, b=carry0, out=timer1Xor);
    
    And(a=timer1, b=carry0, out=and11);
    Or(a=carry0, b=and11, out=carry1);
    Xor(a=timer2, b=carry1, out=timer2Xor);
    
    And(a=timer2, b=carry1, out=and21);
    Or(a=carry1, b=and21, out=carry2);
    Xor(a=timer3, b=carry2, out=timer3Xor);
    
    // 计时器递减使能
    And(a=TimerMode, b=timerNotZero, out=timerDec);
    
    // 选择递减后的值或当前值
    Mux(a=timer0, b=notTimer0, sel=timerDec, out=timer0Dec);
    Mux(a=timer1, b=timer1Xor, sel=timerDec, out=timer1Dec);
    Mux(a=timer2, b=timer2Xor, sel=timerDec, out=timer2Dec);
    Mux(a=timer3, b=timer3Xor, sel=timerDec, out=timer3Dec);
    
    // --- 计时器模式控制 ---
    // 进入计时器模式的条件
    And(a=buttonLatched, b=state110, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);
    
    // 退出计时器模式的条件
    And(a=TimerMode, b=timerZero, out=exitTimer);
    
    // 计时器模式下一状态
    Or(a=enterTimer, b=TimerMode, out=stayOrEnter);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrEnter, b=notExit, out=nextTimerMode);
    
    // 应用计时器复位：进入时设置为9 (1001)
    Mux(a=timer0Dec, b=true, sel=enterTimer, out=nextTimer0);
    Mux(a=timer1Dec, b=false, sel=enterTimer, out=nextTimer1);
    Mux(a=timer2Dec, b=false, sel=enterTimer, out=nextTimer2);
    Mux(a=timer3Dec, b=true, sel=enterTimer, out=nextTimer3);
    
    // --- 按钮锁存逻辑 ---
    Or(a=buttonRisingEdge, b=buttonLatched, out=buttonLatchedOr);
    And(a=buttonLatchedOr, b=notTimerMode, out=nextButtonLatched);
    
    // --- 状态转移逻辑 ---
    // 正常序列：000->001->010->011->100->101->110->000
    
    // 状态0的下一状态位
    Or(a=state000, b=state011, out=orState01);
    Or(a=orState01, b=state110, out=orState02);
    And(a=orState02, b=PowerOn, out=nextState0Base);
    
    // 状态1的下一状态位
    Or(a=state001, b=state010, out=orState11);
    Or(a=state100, b=state101, out=orState12);
    Or(a=orState11, b=orState12, out=orState13);
    And(a=orState13, b=PowerOn, out=nextState1Base);
    
    // 状态2的下一状态位
    Or(a=state100, b=state101, out=orState21);
    Or(a=state110, b=state111, out=orState22);
    Or(a=orState21, b=orState22, out=orState23);
    And(a=orState23, b=PowerOn, out=nextState2Base);
    
    // 应用计时器模式：计时器模式下状态机冻结
    Mux(a=nextState0Base, b=state0, sel=TimerMode, out=nextState0);
    Mux(a=nextState1Base, b=state1, sel=TimerMode, out=nextState1);
    Mux(a=nextState2Base, b=state2, sel=TimerMode, out=nextState2);
    
    // --- 交通灯输出逻辑（中间信号）---
    // X红灯中间信号
    Or(a=state000, b=state011, out=xRedOr1);
    Or(a=state100, b=state101, out=xRedOr2);
    Or(a=state110, b=state111, out=xRedOr3);
    Or(a=xRedOr1, b=xRedOr2, out=xRedOr4);
    Or(a=xRedOr4, b=xRedOr3, out=xRedNormalTemp);
    And(a=xRedNormalTemp, b=PowerOn, out=xRedNormal);
    
    // X黄灯中间信号
    Or(a=state001, b=state011, out=xAmberOr);
    And(a=xAmberOr, b=PowerOn, out=xAmberNormal);
    
    // X绿灯中间信号
    And(a=state010, b=PowerOn, out=xGreenNormal);
    
    // Z红灯中间信号
    Or(a=state000, b=state001, out=zRedOr1);
    Or(a=state010, b=state011, out=zRedOr2);
    Or(a=state100, b=state111, out=zRedOr3);
    Or(a=zRedOr1, b=zRedOr2, out=zRedOr4);
    Or(a=zRedOr4, b=zRedOr3, out=zRedNormalTemp);
    And(a=zRedNormalTemp, b=PowerOn, out=zRedNormal);
    
    // Z黄灯中间信号
    Or(a=state100, b=state110, out=zAmberOr);
    And(a=zAmberOr, b=PowerOn, out=zAmberNormal);
    
    // Z绿灯中间信号
    And(a=state101, b=PowerOn, out=zGreenNormal);
    
    // 应用计时器模式覆盖
    Mux(a=xRedNormal, b=true, sel=TimerMode, out=xRedFinal);
    Mux(a=xAmberNormal, b=false, sel=TimerMode, out=xAmberFinal);
    Mux(a=xGreenNormal, b=false, sel=TimerMode, out=xGreenFinal);
    
    Mux(a=zRedNormal, b=true, sel=TimerMode, out=zRedFinal);
    Mux(a=zAmberNormal, b=false, sel=TimerMode, out=zAmberFinal);
    Mux(a=zGreenNormal, b=false, sel=TimerMode, out=zGreenFinal);
    
    // 最终输出（每个输出只有一个驱动源）
    // X灯输出
    And(a=xRedFinal, b=true, out=X[2]);
    And(a=xAmberFinal, b=true, out=X[1]);
    And(a=xGreenFinal, b=true, out=X[0]);
    
    // Z灯输出
    And(a=zRedFinal, b=true, out=Z[2]);
    And(a=zAmberFinal, b=true, out=Z[1]);
    And(a=zGreenFinal, b=true, out=Z[0]);
    
    // --- Wait信号 ---
    Not(in=TimerMode, out=Wait);
    
    // --- ButtonPressed输出 ---
    And(a=buttonLatched, b=PowerOn, out=ButtonPressed);
    
    // --- 7段数码管输出 ---
    // 使用Decoder将4位计时器值转换为7段显示
    Decoder(in[0]=timer0, in[1]=timer1, in[2]=timer2, in[3]=timer3,
            a=decA, b=decB, c=decC, d=decD, e=decE, f=decF, g=decG);
    
    // 重新排序：根据8.jpg的映射
    // C[6]=a (下横), C[5]=e (上横), C[4]=b (中横), 
    // C[3]=c (右下竖), C[2]=d (左上竖), C[1]=f (右上竖), C[0]=g (左下竖)
    
    // 仅当计时器模式时输出数码管信号
    And(a=decA, b=TimerMode, out=C[6]);  // a -> C[6]
    And(a=decE, b=TimerMode, out=C[5]);  // e -> C[5]
    And(a=decB, b=TimerMode, out=C[4]);  // b -> C[4]
    And(a=decC, b=TimerMode, out=C[3]);  // c -> C[3]
    And(a=decD, b=TimerMode, out=C[2]);  // d -> C[2]
    And(a=decF, b=TimerMode, out=C[1]);  // f -> C[1]
    And(a=decG, b=TimerMode, out=C[0]);  // g -> C[0]
}