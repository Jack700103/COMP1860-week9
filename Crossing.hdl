// ================================================
// Crossing Controller with Pedestrian Timer
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:

    // --- State Registers (5 bits) ---
    // S4: Timer mode (1=countdown, 0=normal)
    // S3: Current light (0=X cycle, 1=Z cycle)
    // S2-S0: State within current cycle
    DFF(in=nextS4, out=S4);
    DFF(in=nextS3, out=S3);
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // --- Timer Register (4 bits) ---
    DFF(in=nextTimer3, out=Timer3);
    DFF(in=nextTimer2, out=Timer2);
    DFF(in=nextTimer1, out=Timer1);
    DFF(in=nextTimer0, out=Timer0);
    
    // --- Create inverted versions of state bits ---
    Not(in=S0, out=notS0);
    Not(in=S1, out=notS1);
    Not(in=S2, out=notS2);
    Not(in=S3, out=notS3);
    Not(in=S4, out=notS4);
    
    // --- Create inverted versions of timer bits ---
    Not(in=Timer0, out=notTimer0);
    Not(in=Timer1, out=notTimer1);
    Not(in=Timer2, out=notTimer2);
    Not(in=Timer3, out=notTimer3);
    
    // --- Button Press Detection ---
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRisingEdge);
    
    // ButtonPressed latch
    DFF(in=nextBP, out=ButtonPressedReg);
    Or(a=ButtonRisingEdge, b=ButtonPressedReg, out=BPOr);
    And(a=BPOr, b=PowerOn, out=BPAnd);
    And(a=BPAnd, b=notS4, out=nextBPInput);
    Mux(a=false, b=nextBPInput, sel=PowerOn, out=nextBP);
    
    // Wait signal: 1 when in normal mode, 0 when in timer mode
    Not(in=S4, out=Wait);
    
    // --- Normal State Transition Logic ---
    // Same as JunctionController but with timer mode control
    
    // State transition logic (from S2,S1,S0)
    Xor(a=S1, b=S0, out=xorS1S0);
    And(a=S1, b=S0, out=andS1S0);
    Xor(a=S2, b=andS1S0, out=xorS2);
    
    // Normal next state
    Mux(a=false, b=xorS2, sel=PowerOn, out=nextS2Normal);
    Mux(a=false, b=xorS1S0, sel=PowerOn, out=nextS1Normal);
    Mux(a=false, b=notS0, sel=PowerOn, out=nextS0Normal);
    
    // S3 logic: toggle when cycle completes
    // Check if at end of cycle (state 100 for X or 000 for Z)
    And(a=S2, b=notS1, out=S2andNotS1);
    And(a=S2andNotS1, b=notS0, out=endOfCycle);
    
    // Toggle S3 at end of cycle
    Xor(a=S3, b=endOfCycle, out=nextS3Normal);
    
    // --- Timer Mode Control ---
    // Enter timer mode when:
    // 1. Button was pressed (ButtonPressedReg=1)
    // 2. Both lights are RED (at the sync point)
    // 3. Power is on
    
    // Check if at sync point (both lights should be RED)
    And(a=S3, b=notS2, out=atZRed);
    And(a=atZRed, b=notS1, out=atZRed2);
    And(a=atZRed2, b=notS0, out=atSyncPoint);
    
    // Conditions to start timer
    And(a=ButtonPressedReg, b=atSyncPoint, out=startTimerCond);
    And(a=startTimerCond, b=PowerOn, out=startTimer);
    
    // Exit timer when count reaches 0
    And(a=notTimer3, b=notTimer2, out=andT32);
    And(a=notTimer1, b=notTimer0, out=andT10);
    And(a=andT32, b=andT10, out=timerZero);
    
    And(a=S4, b=timerZero, out=exitTimer);
    
    // Next S4 (timer mode)
    Or(a=S4, b=startTimer, out=stayOrStart);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrStart, b=notExit, out=nextS4);
    
    // Apply timer mode to state transitions
    Mux(a=nextS2Normal, b=S2, sel=S4, out=nextS2);
    Mux(a=nextS1Normal, b=S1, sel=S4, out=nextS1);
    Mux(a=nextS0Normal, b=S0, sel=S4, out=nextS0);
    Mux(a=nextS3Normal, b=S3, sel=S4, out=nextS3);
    
    // --- Timer Counter Logic ---
    // 4-bit decrementer (counts 9 down to 0)
    
    // Create 4-bit decrementer using full adders
    // Subtract 1 by adding 1111 (two's complement of 1)
    FullAdder(a=Timer0, b=true, c=false, sum=dec0, carry=carry0);
    FullAdder(a=Timer1, b=true, c=carry0, sum=dec1, carry=carry1);
    FullAdder(a=Timer2, b=true, c=carry1, sum=dec2, carry=carry2);
    FullAdder(a=Timer3, b=true, c=carry2, sum=dec3, carry=carry3);
    
    // Select next timer value
    And(a=S4, b=notExit, out=decrement);
    
    // For each timer bit, mux between current, decremented, and 9
    // Timer3 (MSB)
    Mux(a=Timer3, b=dec3, sel=decrement, out=nextTimer3Temp);
    Mux(a=nextTimer3Temp, b=true, sel=startTimer, out=nextTimer3);
    
    // Timer2
    Mux(a=Timer2, b=dec2, sel=decrement, out=nextTimer2Temp);
    Mux(a=nextTimer2Temp, b=false, sel=startTimer, out=nextTimer2);
    
    // Timer1
    Mux(a=Timer1, b=dec1, sel=decrement, out=nextTimer1Temp);
    Mux(a=nextTimer1Temp, b=false, sel=startTimer, out=nextTimer1);
    
    // Timer0 (LSB)
    Mux(a=Timer0, b=dec0, sel=decrement, out=nextTimer0Temp);
    Mux(a=nextTimer0Temp, b=true, sel=startTimer, out=nextTimer0);
    
    // --- Traffic Light Output Logic ---
    // Same as JunctionController, but override with RED in timer mode
    
    // Original logic from JunctionController
    Mux(a=S1, b=false, sel=S2, out=xstate1);
    Mux(a=S0, b=false, sel=S2, out=xstate0);
    
    Mux(a=false, b=S1, sel=S2, out=zstate1);
    Mux(a=false, b=S0, sel=S2, out=zstate0);
    
    // X light outputs
    Not(in=xstate1, out=Xred);
    Or(a=xstate0, b=false, out=Xamber);
    Not(in=xstate0, out=notxstate0);
    And(a=xstate1, b=notxstate0, out=Xgreen);
    
    // Z light outputs
    Not(in=zstate1, out=Zred);
    Or(a=zstate0, b=false, out=Zamber);
    Not(in=zstate0, out=notzstate0);
    And(a=zstate1, b=notzstate0, out=Zgreen);
    
    // Apply timer mode override
    Mux(a=Xred, b=true, sel=S4, out=X[2]);    // RED
    Mux(a=Xamber, b=false, sel=S4, out=X[1]); // AMBER
    Mux(a=Xgreen, b=false, sel=S4, out=X[0]); // GREEN
    
    Mux(a=Zred, b=true, sel=S4, out=Z[2]);    // RED
    Mux(a=Zamber, b=false, sel=S4, out=Z[1]); // AMBER
    Mux(a=Zgreen, b=false, sel=S4, out=Z[0]); // GREEN
    
    // --- 7-Segment Display Decoder ---
    // Based on 8.jpg: segments are arranged as:
    //    e
    //  d   f
    //    b
    //  g   c
    //    a
    // C[6..0] = a, b, c, d, e, f, g
    
    // Segment a (C[6]): on for 0,2,3,5,6,7,8,9
    // Logic: a = Timer3 + notTimer2*notTimer1*notTimer0 + notTimer2*Timer1*Timer0 + Timer2*notTimer1*Timer0 + Timer2*Timer1*notTimer0
    And(a=notTimer2, b=notTimer1, out=anda1);
    And(a=anda1, b=notTimer0, out=terma1);
    
    And(a=notTimer2, b=Timer1, out=anda2);
    And(a=anda2, b=Timer0, out=terma2);
    
    And(a=Timer2, b=notTimer1, out=anda3);
    And(a=anda3, b=Timer0, out=terma3);
    
    And(a=Timer2, b=Timer1, out=anda4);
    And(a=anda4, b=notTimer0, out=terma4);
    
    Or(a=terma1, b=terma2, out=ora1);
    Or(a=terma3, b=terma4, out=ora2);
    Or(a=ora1, b=ora2, out=ora3);
    Or(a=Timer3, b=ora3, out=segAraw);
    And(a=segAraw, b=S4, out=C[6]);
    
    // Segment b (C[5]): on for 0,1,2,3,4,7,8,9
    // Logic: b = notTimer3*notTimer2 + notTimer3*notTimer1*notTimer0 + notTimer3*Timer1*Timer0 + Timer3
    And(a=notTimer3, b=notTimer2, out=termb1);
    
    And(a=notTimer3, b=notTimer1, out=andb1);
    And(a=andb1, b=notTimer0, out=termb2);
    
    And(a=notTimer3, b=Timer1, out=andb2);
    And(a=andb2, b=Timer0, out=termb3);
    
    Or(a=termb1, b=termb2, out=orb1);
    Or(a=orb1, b=termb3, out=orb2);
    Or(a=orb2, b=Timer3, out=segBraw);
    And(a=segBraw, b=S4, out=C[5]);
    
    // Segment c (C[4]): on for 0,1,3,4,5,6,7,8,9
    // Logic: c = notTimer3*notTimer2 + notTimer3*notTimer1*Timer0 + notTimer3*Timer1*notTimer0 + Timer3
    And(a=notTimer3, b=notTimer1, out=andc1);
    And(a=andc1, b=Timer0, out=termc1);
    
    And(a=notTimer3, b=Timer1, out=andc2);
    And(a=andc2, b=notTimer0, out=termc2);
    
    Or(a=termb1, b=termc1, out=orc1);
    Or(a=orc1, b=termc2, out=orc2);
    Or(a=orc2, b=Timer3, out=segCraw);
    And(a=segCraw, b=S4, out=C[4]);
    
    // Segment d (C[3]): on for 0,2,3,5,6,8,9
    // Logic: d = notTimer3*notTimer2*notTimer1*notTimer0 + notTimer3*notTimer2*Timer1*Timer0 + 
    //         notTimer3*Timer2*notTimer1*Timer0 + notTimer3*Timer2*Timer1*notTimer0 + Timer3*notTimer2*notTimer1*notTimer0
    And(a=notTimer3, b=notTimer2, out=andd1);
    And(a=andd1, b=notTimer1, out=andd2);
    And(a=andd2, b=notTimer0, out=termd1);
    
    And(a=andd1, b=Timer1, out=andd3);
    And(a=andd3, b=Timer0, out=termd2);
    
    And(a=notTimer3, b=Timer2, out=andd4);
    And(a=andd4, b=notTimer1, out=andd5);
    And(a=andd5, b=Timer0, out=termd3);
    
    And(a=andd4, b=Timer1, out=andd6);
    And(a=andd6, b=notTimer0, out=termd4);
    
    And(a=Timer3, b=notTimer2, out=andd7);
    And(a=andd7, b=notTimer1, out=andd8);
    And(a=andd8, b=notTimer0, out=termd5);
    
    Or(a=termd1, b=termd2, out=ord1);
    Or(a=ord1, b=termd3, out=ord2);
    Or(a=ord2, b=termd4, out=ord3);
    Or(a=ord3, b=termd5, out=segDraw);
    And(a=segDraw, b=S4, out=C[3]);
    
    // Segment e (C[2]): on for 0,2,6,8
    // Logic: e = notTimer3*notTimer2*notTimer1*notTimer0 + notTimer3*Timer2*notTimer1*notTimer0 + Timer3*notTimer2*notTimer1*notTimer0
    And(a=andd2, b=notTimer0, out=terme1);
    
    And(a=andd4, b=notTimer1, out=ande1);
    And(a=ande1, b=notTimer0, out=terme2);
    
    And(a=andd7, b=notTimer1, out=ande2);
    And(a=ande2, b=notTimer0, out=terme3);
    
    Or(a=terme1, b=terme2, out=ore1);
    Or(a=ore1, b=terme3, out=segEraw);
    And(a=segEraw, b=S4, out=C[2]);
    
    // Segment f (C[1]): on for 0,4,5,6,8,9
    // Logic: f = Timer3 + notTimer2*notTimer1*notTimer0 + Timer2*notTimer1*Timer0 + Timer2*Timer1*notTimer0
    And(a=notTimer2, b=notTimer1, out=andf1);
    And(a=andf1, b=notTimer0, out=termf1);
    
    And(a=Timer2, b=notTimer1, out=andf2);
    And(a=andf2, b=Timer0, out=termf2);
    
    And(a=Timer2, b=Timer1, out=andf3);
    And(a=andf3, b=notTimer0, out=termf3);
    
    Or(a=termf1, b=termf2, out=orf1);
    Or(a=orf1, b=termf3, out=orf2);
    Or(a=Timer3, b=orf2, out=segFraw);
    And(a=segFraw, b=S4, out=C[1]);
    
    // Segment g (C[0]): on for 2,3,4,5,6,8,9
    // Logic: g = Timer3 + notTimer2*Timer1*notTimer0 + Timer2*notTimer1*Timer0 + Timer2*Timer1*notTimer0
    And(a=notTimer2, b=Timer1, out=andg1);
    And(a=andg1, b=notTimer0, out=termg1);
    
    And(a=Timer2, b=notTimer1, out=andg2);
    And(a=andg2, b=Timer0, out=termg2);
    
    And(a=Timer2, b=Timer1, out=andg3);
    And(a=andg3, b=notTimer0, out=termg3);
    
    Or(a=termg1, b=termg2, out=org1);
    Or(a=org1, b=termg3, out=org2);
    Or(a=Timer3, b=org2, out=segGraw);
    And(a=segGraw, b=S4, out=C[0]);
    
    // --- Final Outputs ---
    // ButtonPressed output
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
}
