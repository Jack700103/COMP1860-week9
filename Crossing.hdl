CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    //========================================================
    // 1. 状态寄存器：是否有按键请求 & 是否处于行人过街阶段
    //========================================================
    DFF(in=nextFlag,   out=buttonFlag);   // 本轮是否有人按过按钮
    DFF(in=nextCross,  out=crossing);     // 是否正在给行人过街（计时阶段）

    //========================================================
    // 2. 十字路口正常红绿灯控制（题目第4题的控制器）
    //========================================================
    JunctionController(
        PowerOn = PowerOn,
        X[0] = Xj0, X[1] = Xj1, X[2] = Xj2,
        Z[0] = Zj0, Z[1] = Zj1, Z[2] = Zj2
    );

    //========================================================
    // 3. 检测“两个方向都为红灯”——用来判断一个完整周期结束
    //========================================================
    Not(in=Xj1, out=nXj1);
    Not(in=Xj0, out=nXj0);
    And(a=Xj2, b=nXj1, out=XredPart);
    And(a=XredPart, b=nXj0, out=Xred);

    Not(in=Zj1, out=nZj1);
    Not(in=Zj0, out=nZj0);
    And(a=Zj2, b=nZj1, out=ZredPart);
    And(a=ZredPart, b=nZj0, out=Zred);

    And(a=Xred, b=Zred, out=cycleComplete);

    //========================================================
    // 4. 行人倒计时计数器：CounterDec + Decoder
    //========================================================
    Not(in=PowerOn, out=notPowerOn);
    Not(in=crossing, out=notCrossing);
    // 非过街状态或关机时复位计数器
    Or(a=notPowerOn, b=notCrossing, out=timerReset);

    CounterDec(
        dec   = crossing,
        reset = timerReset,
        out[0] = cnt0, out[1] = cnt1, out[2] = cnt2, out[3] = cnt3
    );

    // 判断计数是否已经减到 0
    Or(a=cnt0, b=cnt1, out=any01);
    Or(a=cnt2, b=cnt3, out=any23);
    Or(a=any01, b=any23, out=anyCnt);
    Not(in=anyCnt, out=timerDone);

    // 4bit → 七段译码
    Decoder(
        in[0]=cnt0, in[1]=cnt1, in[2]=cnt2, in[3]=cnt3,
        a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG
    );

    // 只有在 crossing=1（行人过街计时阶段）才点亮数码管
    Mux(a=segA, b=false, sel=crossing, out=C[0]);
    Mux(a=segB, b=false, sel=crossing, out=C[1]);
    Mux(a=segC, b=false, sel=crossing, out=C[2]);
    Mux(a=segD, b=false, sel=crossing, out=C[3]);
    Mux(a=segE, b=false, sel=crossing, out=C[4]);
    Mux(a=segF, b=false, sel=crossing, out=C[5]);
    Mux(a=segG, b=false, sel=crossing, out=C[6]);

    //========================================================
    // 5. 按钮逻辑：ButtonPressed = “本轮是否有人按过按钮”
    //========================================================
    // 清零条件：正在过街且计时结束
    And(a=crossing, b=timerDone, out=clearFlag);

    // 置位：Button 高电平任意时刻都置位
    Or(a=Button, b=buttonFlag, out=flagOrButton);

    Not(in=clearFlag, out=notClearFlag);
    And(a=flagOrButton, b=notClearFlag, out=flagTemp);

    // PowerOn=0 时强制清零
    Mux(a=flagTemp, b=false, sel=notPowerOn, out=nextFlag);

    Or(a=buttonFlag, b=false, out=ButtonPressed);

    //========================================================
    // 6. crossing 状态机：
    //    - buttonFlag & cycleComplete → 进入过街阶段
    //    - crossing & !timerDone      → 维持过街
    //    - crossing & timerDone       → 退出过街
    //========================================================
    And(a=buttonFlag, b=cycleComplete, out=startCross);
    Not(in=timerDone, out=notTimerDone);
    And(a=crossing, b=notTimerDone, out=stayCross);
    Or(a=startCross, b=stayCross, out=nextCrossTemp);

    // PowerOn=0 时 crossing 归零
    Mux(a=nextCrossTemp, b=false, sel=notPowerOn, out=nextCross);

    //========================================================
    // 7. Wait 信号：只要系统开机且不在行人过街阶段，就必须等待
    //========================================================
    Not(in=crossing, out=notCrossing2);
    And(a=notCrossing2, b=PowerOn, out=Wait);

    //========================================================
    // 8. 最终红绿灯输出：
    //    - 正常时跟随 JunctionController
    //    - crossing=1 时两个方向都保持“红灯亮、黄绿灭”
    //========================================================
    Mux(a=Xj0, b=false, sel=crossing, out=X[0]);
    Mux(a=Xj1, b=false, sel=crossing, out=X[1]);
    Mux(a=Xj2, b=true,  sel=crossing, out=X[2]);

    Mux(a=Zj0, b=false, sel=crossing, out=Z[0]);
    Mux(a=Zj1, b=false, sel=crossing, out=Z[1]);
    Mux(a=Zj2, b=true,  sel=crossing, out=Z[2]);
}
