CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    // ========== 主控制器状态机 ==========
    // 状态定义: 
    // 000: 初始状态，两个灯都红
    // 001: X灯正常循环
    // 010: Z灯正常循环
    // 011: 等待行人过街状态
    // 100: 计时状态
    
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 解码当前状态
    Not(in=state0, out=notS0);
    Not(in=state1, out=notS1);
    Not(in=state2, out=notS2);
    
    // 状态000: 初始状态
    And(a=notS0, b=notS1, out=andInit1);
    And(a=andInit1, b=notS2, out=stateInit);
    
    // 状态001: X灯循环
    And(a=state0, b=notS1, out=andXCycle1);
    And(a=andXCycle1, b=notS2, out=stateXCycle);
    
    // 状态010: Z灯循环
    And(a=notS0, b=state1, out=andZCycle1);
    And(a=andZCycle1, b=notS2, out=stateZCycle);
    
    // 状态011: 等待状态
    And(a=state0, b=state1, out=andWait1);
    And(a=andWait1, b=notS2, out=stateWait);
    
    // 状态100: 计时状态
    And(a=notS0, b=notS1, out=andTimer1);
    And(a=andTimer1, b=state2, out=stateTimer);
    
    // ========== 交通灯控制器 ==========
    // 子状态机控制单个交通灯序列
    // 状态: 00=RED, 01=RED/AMBER, 10=GREEN, 11=AMBER
    
    DFF(in=nextXState0, out=xState0);
    DFF(in=nextXState1, out=xState1);
    DFF(in=nextZState0, out=zState0);
    DFF(in=nextZState1, out=zState1);
    
    // X灯状态转换逻辑
    And(a=stateXCycle, b=PowerOn, out=xActive);
    Not(in=xState0, out=notX0);
    Not(in=xState1, out=notX1);
    
    // X灯状态机: 00→01→10→11→00
    Xor(a=xState0, b=xState1, out=xNext0Temp);
    And(a=xState0, b=xState1, out=xCarry);
    Xor(a=xState1, b=xCarry, out=xNext1Temp);
    
    // 只在X灯活动时更新状态
    Mux(a=xState0, b=xNext0Temp, sel=xActive, out=xNext0);
    Mux(a=xState1, b=xNext1Temp, sel=xActive, out=xNext1);
    
    // Z灯状态转换逻辑
    And(a=stateZCycle, b=PowerOn, out=zActive);
    Not(in=zState0, out=notZ0);
    Not(in=zState1, out=notZ1);
    
    // Z灯状态机: 00→01→10→11→00
    Xor(a=zState0, b=zState1, out=zNext0Temp);
    And(a=zState0, b=zState1, out=zCarry);
    Xor(a=zState1, b=zCarry, out=zNext1Temp);
    
    // 只在Z灯活动时更新状态
    Mux(a=zState0, b=zNext0Temp, sel=zActive, out=zNext0);
    Mux(a=zState1, b=zNext1Temp, sel=zActive, out=zNext1);
    
    // 复位逻辑
    Mux(a=xNext0, b=false, sel=PowerOn, out=finalXNext0);
    Mux(a=xNext1, b=false, sel=PowerOn, out=finalXNext1);
    Mux(a=zNext0, b=false, sel=PowerOn, out=finalZNext0);
    Mux(a=zNext1, b=false, sel=PowerOn, out=finalZNext1);
    
    // 交通灯输出编码
    // X灯输出: X[2]=RED, X[1]=AMBER, X[0]=GREEN
    // 状态到灯光的映射:
    // 00(0): RED=1, AMBER=0, GREEN=0 (100)
    // 01(1): RED=1, AMBER=1, GREEN=0 (110)
    // 10(2): RED=0, AMBER=0, GREEN=1 (001)
    // 11(3): RED=0, AMBER=1, GREEN=0 (010)
    
    // X灯输出逻辑
    And(a=notX0, b=notX1, out=xRedState);      // 00
    And(a=xState0, b=notX1, out=xRedAmber);    // 01
    And(a=notX0, b=xState1, out=xGreen);       // 10
    And(a=xState0, b=xState1, out=xAmber);     // 11
    
    Or(a=xRedState, b=xRedAmber, out=X[2]);    // RED灯
    Or(a=xRedAmber, b=xAmber, out=X[1]);       // AMBER灯
    Or(a=false, b=xGreen, out=X[0]);           // GREEN灯
    
    // Z灯输出逻辑
    And(a=notZ0, b=notZ1, out=zRedState);      // 00
    And(a=zState0, b=notZ1, out=zRedAmber);    // 01
    And(a=notZ0, b=zState1, out=zGreen);       // 10
    And(a=zState0, b=zState1, out=zAmber);     // 11
    
    Or(a=zRedState, b=zRedAmber, out=Z[2]);    // RED灯
    Or(a=zRedAmber, b=zAmber, out=Z[1]);       // AMBER灯
    Or(a=false, b=zGreen, out=Z[0]);           // GREEN灯
    
    // ========== 按钮检测逻辑 ==========
    DFF(in=nextButtonReg, out=buttonReg);
    
    // 按钮检测：在非计时状态下按下按钮
    Not(in=stateTimer, out=notStateTimer);
    And(a=Button, b=notStateTimer, out=buttonDetected);
    Or(a=buttonDetected, b=buttonReg, out=buttonSet);
    
    // 在计时结束时清除按钮标志
    And(a=stateTimer, b=timerDone, out=buttonClear);
    Not(in=buttonClear, out=notButtonClear);
    
    And(a=buttonSet, b=notButtonClear, out=buttonTemp);
    Mux(a=buttonTemp, b=false, sel=PowerOn, out=nextButtonReg);
    Or(a=buttonReg, b=false, out=ButtonPressed);
    
    // ========== 计时器逻辑 ==========
    // 9到0的倒计时
    CounterDec(dec=stateTimer, reset=resetTimer, out[0]=count0, out[1]=count1, out[2]=count2, out[3]=count3);
    
    // 计时器复位条件
    Not(in=PowerOn, out=notPowerOn);
    Or(a=notPowerOn, b=notStateTimer, out=resetTimer);
    
    // 计时完成检测（当计数为0时）
    Not(in=count0, out=notCount0);
    Not(in=count1, out=notCount1);
    Not(in=count2, out=notCount2);
    Not(in=count3, out=notCount3);
    
    And(a=notCount0, b=notCount1, out=andTimerDone1);
    And(a=notCount2, b=notCount3, out=andTimerDone2);
    And(a=andTimerDone1, b=andTimerDone2, out=timerDone);
    
    // ========== 7段显示解码 ==========
    Decoder(in[0]=count0, in[1]=count1, in[2]=count2, in[3]=count3, 
            a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG);
    
    // 根据8.jpg的映射关系重排段序
    // 原顺序: a=下横, e=上横, b=中横, c=右下竖, d=左上竖, f=右上竖, g=左下竖
    // 我们需要映射到C[0..6]
    // 假设C[0]=a, C[1]=b, C[2]=c, C[3]=d, C[4]=e, C[5]=f, C[6]=g
    
    Mux(a=false, b=segA, sel=stateTimer, out=C[0]);  // a段
    Mux(a=false, b=segB, sel=stateTimer, out=C[1]);  // b段
    Mux(a=false, b=segC, sel=stateTimer, out=C[2]);  // c段
    Mux(a=false, b=segD, sel=stateTimer, out=C[3]);  // d段
    Mux(a=false, b=segE, sel=stateTimer, out=C[4]);  // e段
    Mux(a=false, b=segF, sel=stateTimer, out=C[5]);  // f段
    Mux(a=false, b=segG, sel=stateTimer, out=C[6]);  // g段
    
    // ========== 主状态机转换逻辑 ==========
    // 条件检测
    And(a=xRedState, b=zRedState, out=bothRed);
    And(a=bothRed, b=buttonReg, out=pedestrianRequest);
    
    // 状态转换
    // 初始状态 → X灯循环
    And(a=stateInit, b=PowerOn, out=toXCycle);
    
    // X灯循环完成 → Z灯循环
    And(a=stateXCycle, b=xRedState, out=xCycleDone);
    
    // Z灯循环完成 → 检查是否需要等待行人
    And(a=stateZCycle, b=zRedState, out=zCycleDone);
    
    // 等待状态 → 计时状态
    Or(a=stateWait, b=stateWait, out=toTimer);  // 直接进入计时状态
    
    // 计时完成 → 初始状态
    And(a=stateTimer, b=timerDone, out=timerComplete);
    
    // ========== 主状态机下一状态计算 ==========
    // 下一状态0的逻辑
    Or(a=stateInit, b=stateWait, out=nextS0Temp1);
    Or(a=nextS0Temp1, b=stateTimer, out=nextS0Temp2);
    Mux(a=nextS0Temp2, b=stateXCycle, sel=PowerOn, out=nextS0Temp3);
    Mux(a=nextS0Temp3, b=false, sel=PowerOn, out=nextState0);
    
    // 下一状态1的逻辑
    Or(a=stateZCycle, b=stateWait, out=nextS1Temp1);
    Mux(a=false, b=nextS1Temp1, sel=PowerOn, out=nextS1Temp2);
    Mux(a=nextS1Temp2, b=false, sel=PowerOn, out=nextState1);
    
    // 下一状态2的逻辑
    Mux(a=false, b=stateTimer, sel=PowerOn, out=nextS2Temp1);
    Mux(a=nextS2Temp1, b=false, sel=PowerOn, out=nextState2);
    
    // 特殊：当Z灯循环完成且有行人请求时，进入等待状态
    And(a=stateZCycle, b=zCycleDone, out=andEnterWait1);
    And(a=andEnterWait1, b=pedestrianRequest, out=enterWait);
    
    // 处理进入等待状态的逻辑
    Mux(a=nextState0, b=true, sel=enterWait, out=finalNextS0);
    Mux(a=nextState1, b=true, sel=enterWait, out=finalNextS1);
    Mux(a=nextState2, b=false, sel=enterWait, out=finalNextS2);
    
    // Wait信号输出
    Not(in=stateTimer, out=notInTimer);
    And(a=stateWait, b=notInTimer, out=Wait);
    
    // 最终交通灯输出覆盖
    // 在计时状态，两个灯都设为红
    Mux(a=X[0], b=false, sel=stateTimer, out=finalX0);
    Mux(a=X[1], b=false, sel=stateTimer, out=finalX1);
    Mux(a=X[2], b=true, sel=stateTimer, out=finalX2);
    
    Mux(a=Z[0], b=false, sel=stateTimer, out=finalZ0);
    Mux(a=Z[1], b=false, sel=stateTimer, out=finalZ1);
    Mux(a=Z[2], b=true, sel=stateTimer, out=finalZ2);
    
    // 连接最终输出
    Or(a=finalX0, b=false, out=X[0]);
    Or(a=finalX1, b=false, out=X[1]);
    Or(a=finalX2, b=false, out=X[2]);
    Or(a=finalZ0, b=false, out=Z[0]);
    Or(a=finalZ1, b=false, out=Z[1]);
    Or(a=finalZ2, b=false, out=Z[2]);
    
    // 连接到下一状态寄存器
    Or(a=finalNextS0, b=false, out=nextState0);
    Or(a=finalNextS1, b=false, out=nextState1);
    Or(a=finalNextS2, b=false, out=nextState2);
    
    // 连接到交通灯下一状态寄存器
    Or(a=finalXNext0, b=false, out=nextXState0);
    Or(a=finalXNext1, b=false, out=nextXState1);
    Or(a=finalZNext0, b=false, out=nextZState0);
    Or(a=finalZNext1, b=false, out=nextZState1);
}