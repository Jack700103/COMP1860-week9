CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    // 状态寄存器：s1 s0 组成 3 个状态
    // state0: 正常运行、未请求
    // state1: 已按键，等待两个方向都红灯
    // state2: 行人过街计时
    DFF(in=nexts0, out=s0);
    DFF(in=nexts1, out=s1);
    // 记住“有人按过按钮”的标志
    DFF(in=nextbuttonFlag, out=buttonFlag);
    // 状态译码
    Not(in=s0, out=nots0);
    Not(in=s1, out=nots1);
    And(a=nots0, b=nots1, out=state0); // 00
    And(a=s0, b=nots1, out=state1); // 01
    And(a=nots0, b=s1, out=state2); // 10
    // 交通灯控制器（两方向正常轮转），复制内部部件并添加暂停逻辑
    DFF(in=final_nextS2, out=S2);
    DFF(in=final_nextS1, out=S1);
    DFF(in=final_nextS0, out=S0);
    Not(in=S0, out=notS0);
    Xor(a=S1, b=S0, out=xorS1S0);
    And(a=S1, b=S0, out=andS1S0);
    Xor(a=S2, b=andS1S0, out=xorS2);
    Mux(a=false, b=xorS2, sel=PowerOn, out=normal_nextS2);
    Mux(a=false, b=xorS1S0, sel=PowerOn, out=normal_nextS1);
    Mux(a=false, b=notS0, sel=PowerOn, out=normal_nextS0);
    // 在state2时暂停状态更新
    Mux(a=normal_nextS2, b=S2, sel=state2, out=final_nextS2);
    Mux(a=normal_nextS1, b=S1, sel=state2, out=final_nextS1);
    Mux(a=normal_nextS0, b=S0, sel=state2, out=final_nextS0);
    // 灯光解码
    Mux(a=S1, b=false, sel=S2, out=xstate1);
    Mux(a=S0, b=false, sel=S2, out=xstate0);
    Mux(a=false, b=S1, sel=S2, out=zstate1);
    Mux(a=false, b=S0, sel=S2, out=zstate0);
    Not(in=xstate1, out=Xjunc2);
    Or(a=xstate0, b=false, out=Xjunc1);
    Not(in=xstate0, out=notxstate0);
    And(a=xstate1, b=notxstate0, out=Xjunc0);
    Not(in=zstate1, out=Zjunc2);
    Or(a=zstate0, b=false, out=Zjunc1);
    Not(in=zstate0, out=notzstate0);
    And(a=zstate1, b=notzstate0, out=Zjunc0);
    // 判断 X 是否为红灯：X = 100
    Not(in=Xjunc1, out=notXjunc1);
    Not(in=Xjunc0, out=notXjunc0);
    And(a=Xjunc2, b=notXjunc1, out=XisRedPart);
    And(a=XisRedPart, b=notXjunc0, out=XisRed);
    // 判断 Z 是否为红灯：Z = 100
    Not(in=Zjunc1, out=notZjunc1);
    Not(in=Zjunc0, out=notZjunc0);
    And(a=Zjunc2, b=notZjunc1, out=ZisRedPart);
    And(a=ZisRedPart, b=notZjunc0, out=ZisRed);
    // 两个方向都红灯，说明一轮车流周期结束
    And(a=XisRed, b=ZisRed, out=cycleComplete);
    // 按钮逻辑：只有在 state0（完全空闲）时，按键才会被记住
    And(a=state0, b=Button, out=setButtonFlag);
    And(a=state2, b=timerDone, out=clearButtonFlag);
    Or(a=setButtonFlag, b=buttonFlag, out=buttonFlagBeforeClear);
    Not(in=clearButtonFlag, out=notClearButtonFlag);
    And(a=buttonFlagBeforeClear, b=notClearButtonFlag, out=buttonFlagTemp);
    // 断电时清零 buttonFlag
    Not(in=PowerOn, out=notPowerOn);
    Mux(a=buttonFlagTemp, b=false, sel=notPowerOn, out=nextbuttonFlag);
    // 输出“ButtonPressed” = 当前是否有有效的过街请求
    Or(a=buttonFlag, b=false, out=ButtonPressed);
    // **关键修正**：Wait 只在 state1 高电平（已经按键但还不能过）
    Or(a=state1, b=false, out=Wait);
    // state2（行人过街）时，强制两方向都红灯；否则正常跟随路口控制器
    Mux(a=Xjunc0, b=false, sel=state2, out=X[0]); // GREEN
    Mux(a=Xjunc1, b=false, sel=state2, out=X[1]); // AMBER
    Mux(a=Xjunc2, b=true, sel=state2, out=X[2]); // RED
    Mux(a=Zjunc0, b=false, sel=state2, out=Z[0]);
    Mux(a=Zjunc1, b=false, sel=state2, out=Z[1]);
    Mux(a=Zjunc2, b=true, sel=state2, out=Z[2]);
    // 计时器：state2 时递减计数，其他时候复位
    Not(in=state2, out=notState2);
    Or(a=notPowerOn, b=notState2, out=timerReset);
    CounterDec(
        dec = state2,
        reset = timerReset,
        out[0] = count0,
        out[1] = count1,
        out[2] = count2,
        out[3] = count3
    );
    // 计数器是否已经减到 0
    Or(a=count0, b=count1, out=anyBit01);
    Or(a=count2, b=count3, out=anyBit23);
    Or(a=anyBit01, b=anyBit23, out=anyBitSet);
    Not(in=anyBitSet, out=timerDone);
    // 7 段译码，显示当前倒计时
    Decoder(
        in[0] = count0,
        in[1] = count1,
        in[2] = count2,
        in[3] = count3,
        a = deca,
        b = decb,
        c = decc,
        d = decd,
        e = dece,
        f = decf,
        g = decg
    );
    // 只在 state2 时点亮数码管，否则全部熄灭
    Mux(a=false, b=deca, sel=state2, out=C[0]);
    Mux(a=false, b=decb, sel=state2, out=C[1]);
    Mux(a=false, b=decc, sel=state2, out=C[2]);
    Mux(a=false, b=decd, sel=state2, out=C[3]);
    Mux(a=false, b=dece, sel=state2, out=C[4]);
    Mux(a=false, b=decf, sel=state2, out=C[5]);
    Mux(a=false, b=decg, sel=state2, out=C[6]);
    // FSM：状态转移
    // state0 在有 buttonFlag 时转入 state1
    And(a=state0, b=buttonFlag, out=condition0to1);
    And(a=state0, b=condition0to1, out=toState1);
    // state1 在车流周期未结束时保持
    Not(in=cycleComplete, out=notCycleComplete);
    And(a=state1, b=notCycleComplete, out=stayState1);
    Or(a=toState1, b=stayState1, out=nexts0temp);
    // state1 在 cycleComplete 时转入 state2
    And(a=state1, b=cycleComplete, out=toState2);
    // state2 在 timerDone 之前保持
    Not(in=timerDone, out=notTimerDone);
    And(a=state2, b=notTimerDone, out=stayState2);
    Or(a=toState2, b=stayState2, out=nexts1temp);
    // 断电时强制回到 state0 (s1s0=00)
    Mux(a=nexts0temp, b=false, sel=notPowerOn, out=nexts0);
    Mux(a=nexts1temp, b=false, sel=notPowerOn, out=nexts1);
}