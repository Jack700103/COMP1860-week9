// ================================================
// Crossing Controller with Pedestrian Timer
// 修正版本 - 修复And芯片使用问题
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    
    // --- 状态寄存器 (3位) ---
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 反相信号
    Not(in=state0, out=notState0);
    Not(in=state1, out=notState1);
    Not(in=state2, out=notState2);
    
    // --- 按钮检测和锁存 ---
    DFF(in=Button, out=buttonPrev);
    Not(in=buttonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=buttonRisingEdge);
    
    // 按钮锁存寄存器
    DFF(in=nextButtonLatched, out=buttonLatched);
    
    // --- 状态解码 ---
    // 使用多个And组合实现多输入与操作
    
    // 状态000: 双红灯
    And(a=notState2, b=notState1, out=andS2S1000);
    And(a=andS2S1000, b=notState0, out=state000);
    
    // 状态001: X红黄灯
    And(a=notState2, b=notState1, out=andS2S1001);
    And(a=andS2S1001, b=state0, out=state001);
    
    // 状态010: X绿灯
    And(a=notState2, b=state1, out=andS2S1010);
    And(a=andS2S1010, b=notState0, out=state010);
    
    // 状态011: X黄灯
    And(a=notState2, b=state1, out=andS2S1011);
    And(a=andS2S1011, b=state0, out=state011);
    
    // 状态100: Z红黄灯
    And(a=state2, b=notState1, out=andS2S1100);
    And(a=andS2S1100, b=notState0, out=state100);
    
    // 状态101: Z绿灯
    And(a=state2, b=notState1, out=andS2S1101);
    And(a=andS2S1101, b=state0, out=state101);
    
    // 状态110: Z黄灯
    And(a=state2, b=state1, out=andS2S1110);
    And(a=andS2S1110, b=notState0, out=state110);
    
    // 状态111: 计时器模式
    And(a=state2, b=state1, out=andS2S1111);
    And(a=andS2S1111, b=state0, out=state111);
    
    // --- 计时器逻辑 ---
    // 简化版计时器：使用4位寄存器
    DFF(in=nextTimer0, out=timer0);
    DFF(in=nextTimer1, out=timer1);
    DFF(in=nextTimer2, out=timer2);
    DFF(in=nextTimer3, out=timer3);
    
    // 检测计时器是否为0
    Or(a=timer0, b=timer1, out=orTimer01);
    Or(a=timer2, b=timer3, out=orTimer23);
    Or(a=orTimer01, b=orTimer23, out=timerNotZero);
    Not(in=timerNotZero, out=timerZero);
    
    // --- 状态转移逻辑 ---
    
    // 进入计时器模式条件：按钮已锁存且处于Z黄灯状态
    And(a=buttonLatched, b=state110, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);
    
    // 退出计时器模式条件：计时器为0且处于计时器模式
    And(a=state111, b=timerZero, out=exitTimer);
    
    // 正常状态转移
    // 状态机序列：000->001->010->011->100->101->110->000
    
    // 状态0的下一状态位
    // 当状态为000, 011, 110, 111时，下一状态的state0=1
    Or(a=state000, b=state011, out=orState01);
    Or(a=orState01, b=state110, out=orState02);
    Or(a=orState02, b=state111, out=orState03);
    And(a=orState03, b=PowerOn, out=nextState0Base);
    
    // 状态1的下一状态位
    // 当状态为001, 010, 100, 101时，下一状态的state1=1
    Or(a=state001, b=state010, out=orState11);
    Or(a=state100, b=state101, out=orState12);
    Or(a=orState11, b=orState12, out=orState13);
    And(a=orState13, b=PowerOn, out=nextState1Base);
    
    // 状态2的下一状态位
    // 当状态为100, 101, 110, 111时，下一状态的state2=1
    Or(a=state100, b=state101, out=orState21);
    Or(a=state110, b=state111, out=orState22);
    Or(a=orState21, b=orState22, out=orState23);
    And(a=orState23, b=PowerOn, out=nextState2Base);
    
    // 应用计时器模式
    // 如果进入计时器模式，下一状态为111
    Mux(a=nextState0Base, b=true, sel=enterTimer, out=nextState0Temp);
    Mux(a=nextState1Base, b=true, sel=enterTimer, out=nextState1Temp);
    Mux(a=nextState2Base, b=true, sel=enterTimer, out=nextState2Temp);
    
    // 如果退出计时器模式，下一状态为000
    Mux(a=nextState0Temp, b=false, sel=exitTimer, out=nextState0);
    Mux(a=nextState1Temp, b=false, sel=exitTimer, out=nextState1);
    Mux(a=nextState2Temp, b=false, sel=exitTimer, out=nextState2);
    
    // --- 按钮锁存逻辑 ---
    // 按钮按下时锁存，计时器模式结束时清除
    Or(a=buttonRisingEdge, b=buttonLatched, out=buttonLatchedOr);
    And(a=buttonLatchedOr, b=notState111, out=nextButtonLatched);
    
    // --- 交通灯输出逻辑 ---
    
    // X灯输出: X[2]=红, X[1]=黄, X[0]=绿
    // X红灯亮当：状态000, 100, 101, 110, 111
    Or(a=state000, b=state100, out=xRedOr1);
    Or(a=xRedOr1, b=state101, out=xRedOr2);
    Or(a=xRedOr2, b=state110, out=xRedOr3);
    Or(a=xRedOr3, b=state111, out=xRedOr4);
    And(a=xRedOr4, b=PowerOn, out=X[2]);
    
    // X黄灯亮当：状态001或011
    Or(a=state001, b=state011, out=xAmberOr);
    And(a=xAmberOr, b=PowerOn, out=X[1]);
    
    // X绿灯亮当：状态010
    And(a=state010, b=PowerOn, out=X[0]);
    
    // Z灯输出: Z[2]=红, Z[1]=黄, Z[0]=绿
    // Z红灯亮当：状态000, 001, 010, 011, 111
    Or(a=state000, b=state001, out=zRedOr1);
    Or(a=zRedOr1, b=state010, out=zRedOr2);
    Or(a=zRedOr2, b=state011, out=zRedOr3);
    Or(a=zRedOr3, b=state111, out=zRedOr4);
    And(a=zRedOr4, b=PowerOn, out=Z[2]);
    
    // Z黄灯亮当：状态100或110
    Or(a=state100, b=state110, out=zAmberOr);
    And(a=zAmberOr, b=PowerOn, out=Z[1]);
    
    // Z绿灯亮当：状态101
    And(a=state101, b=PowerOn, out=Z[0]);
    
    // --- Wait信号 ---
    // Wait=1表示交通灯在正常序列中，不能过街
    // Wait=0表示在计时器模式，可以过街
    Not(in=state111, out=Wait);
    
    // --- ButtonPressed输出 ---
    And(a=buttonLatched, b=PowerOn, out=ButtonPressed);
    
    // --- 7段数码管输出 ---
    // 根据8.jpg的段位顺序: 
    // a=下横段线在底端, e=上横段线在顶端, b=中横段线在中间
    // d=左上竖段线在左上端, f=右上竖段线在右上端
    // g=左下竖段线在左下端, c=右下竖段线在右下端
    // 输出顺序: C[6]=a, C[5]=e, C[4]=b, C[3]=c, C[2]=d, C[1]=f, C[0]=g
    
    // 在计时器模式下显示数字，非计时器模式全灭
    
    // 首先，将4位计时器值转换为7段显示
    // 这里简化处理：假设有一个7段解码器可用
    
    // 计时器值到7段显示的映射
    // 我们需要根据timer0-timer3的值生成对应的段码
    
    // 简化方案：根据计时器值直接生成段码
    // 注意：这是一个简化的实现，实际应该使用专门的解码器
    
    // 显示数字0-9的段码
    // 根据8.jpg的顺序：a,e,b,c,d,f,g
    
    // 数字0: a,e,b,c,d,f亮 = 1111110
    // 数字1: b,c亮 = 0110000  
    // 数字2: a,b,d,e,g亮 = 1101101
    // 数字3: a,b,c,d,g亮 = 1111001
    // 数字4: b,c,f,g亮 = 0110011
    // 数字5: a,c,d,f,g亮 = 1011011
    // 数字6: a,c,d,e,f,g亮 = 1011111
    // 数字7: a,b,c亮 = 1110000
    // 数字8: 全亮 = 1111111
    // 数字9: a,b,c,d,f,g亮 = 1111011
    
    // 由于实现完整的解码器很复杂，这里先显示固定模式
    // 计时器模式时显示数字8（全亮）
    And(a=state111, b=PowerOn, out=timerActive);
    
    // 段a (C[6])
    Mux(a=false, b=true, sel=timerActive, out=C[6]);
    
    // 段e (C[5])
    Mux(a=false, b=true, sel=timerActive, out=C[5]);
    
    // 段b (C[4])
    Mux(a=false, b=true, sel=timerActive, out=C[4]);
    
    // 段c (C[3])
    Mux(a=false, b=true, sel=timerActive, out=C[3]);
    
    // 段d (C[2])
    Mux(a=false, b=true, sel=timerActive, out=C[2]);
    
    // 段f (C[1])
    Mux(a=false, b=true, sel=timerActive, out=C[1]);
    
    // 段g (C[0])
    Mux(a=false, b=true, sel=timerActive, out=C[0]);
    
    // 注意：这是一个简化版本，实际需要根据计时器值显示不同的数字
    // 完整的实现需要解码器逻辑
}