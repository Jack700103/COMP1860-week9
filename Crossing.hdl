// ================================================
// Crossing Controller with Pedestrian Timer
// 完全重设计 - 简化状态机
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:

    DFF(in=nextS0, out=S0);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS2, out=S2);
    DFF(in=nextS3, out=S3);

    Not(in=S0, out=notS0);
    Not(in=S1, out=notS1);
    Not(in=S2, out=notS2);
    Not(in=S3, out=notS3);

    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);

    And(a=notS3, b=notS2, out=and01);
    And(a=notS1, b=notS0, out=and02);
    And(a=and01, b=and02, out=state0);

    And(a=notS3, b=notS2, out=and11);
    And(a=notS1, b=S0, out=and12);
    And(a=and11, b=and12, out=state1);

    And(a=notS3, b=notS2, out=and21);
    And(a=S1, b=notS0, out=and22);
    And(a=and21, b=and22, out=state2);

    And(a=notS3, b=notS2, out=and31);
    And(a=S1, b=S0, out=and32);
    And(a=and31, b=and32, out=state3);

    And(a=notS3, b=S2, out=and41);
    And(a=notS1, b=notS0, out=and42);
    And(a=and41, b=and42, out=state4);

    And(a=notS3, b=S2, out=and51);
    And(a=notS1, b=S0, out=and52);
    And(a=and51, b=and52, out=state5);

    And(a=notS3, b=S2, out=and61);
    And(a=S1, b=notS0, out=and62);
    And(a=and61, b=and62, out=state6);

    And(a=notS3, b=S2, out=and71);
    And(a=S1, b=S0, out=and72);
    And(a=and71, b=and72, out=state7);

    And(a=S3, b=notS2, out=and81);
    And(a=notS1, b=notS0, out=and82);
    And(a=and81, b=and82, out=state8);

    And(a=S3, b=notS2, out=and91);
    And(a=notS1, b=S0, out=and92);
    And(a=and91, b=and92, out=state9);

    DFF(in=Button, out=buttonPrev);
    Not(in=buttonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=buttonRisingEdge);

    DFF(in=nextButtonLatched, out=buttonLatched);

    DFF(in=nextTimer0, out=timer0);
    DFF(in=nextTimer1, out=timer1);
    DFF(in=nextTimer2, out=timer2);
    DFF(in=nextTimer3, out=timer3);

    Or(a=timer0, b=timer1, out=orTimer01);
    Or(a=timer2, b=timer3, out=orTimer23);
    Or(a=orTimer01, b=orTimer23, out=timerNotZero);
    Not(in=timerNotZero, out=timerZero);

    Not(in=timer0, out=notTimer0);

    And(a=timerDec, b=timer0, out=carry0);
    Xor(a=timer1, b=carry0, out=timer1Xor);
    
    And(a=timer1, b=carry0, out=and11);
    Or(a=carry0, b=and11, out=carry1);
    Xor(a=timer2, b=carry1, out=timer2Xor);
    
    And(a=timer2, b=carry1, out=and21);
    Or(a=carry1, b=and21, out=carry2);
    Xor(a=timer3, b=carry2, out=timer3Xor);

    And(a=TimerMode, b=timerNotZero, out=timerDec);

    Mux(a=timer0, b=notTimer0, sel=timerDec, out=timer0Dec);
    Mux(a=timer1, b=timer1Xor, sel=timerDec, out=timer1Dec);
    Mux(a=timer2, b=timer2Xor, sel=timerDec, out=timer2Dec);
    Mux(a=timer3, b=timer3Xor, sel=timerDec, out=timer3Dec);

    And(a=buttonLatched, b=state7, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);

    And(a=TimerMode, b=timerZero, out=exitTimer);

    Or(a=enterTimer, b=TimerMode, out=stayOrEnter);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrEnter, b=notExit, out=nextTimerMode);

    Mux(a=timer0Dec, b=true, sel=enterTimer, out=nextTimer0);
    Mux(a=timer1Dec, b=false, sel=enterTimer, out=nextTimer1);
    Mux(a=timer2Dec, b=false, sel=enterTimer, out=nextTimer2);
    Mux(a=timer3Dec, b=true, sel=enterTimer, out=nextTimer3);

    Or(a=buttonRisingEdge, b=buttonLatched, out=buttonLatchedOr);
    And(a=buttonLatchedOr, b=notTimerMode, out=nextButtonLatched);
    
    Or(a=state0, b=state3, out=orS01);
    Or(a=state7, b=state8, out=orS02);
    Or(a=orS01, b=orS02, out=orS03);
    And(a=orS03, b=PowerOn, out=nextS0Base);

    Or(a=state1, b=state2, out=orS11);
    Or(a=state5, b=state6, out=orS12);
    Or(a=orS11, b=orS12, out=orS13);
    And(a=orS13, b=PowerOn, out=nextS1Base);

    Or(a=state4, b=state5, out=orS21);
    Or(a=state6, b=state7, out=orS22);
    Or(a=orS21, b=orS22, out=orS23);
    And(a=orS23, b=PowerOn, out=nextS2Base);

    Or(a=state8, b=state9, out=orS31);
    And(a=orS31, b=PowerOn, out=nextS3Base);

    Mux(a=nextS0Base, b=false, sel=enterTimer, out=nextS0Temp);
    Mux(a=nextS1Base, b=false, sel=enterTimer, out=nextS1Temp);
    Mux(a=nextS2Base, b=false, sel=enterTimer, out=nextS2Temp);
    Mux(a=nextS3Base, b=true, sel=enterTimer, out=nextS3Temp);
    
    Mux(a=nextS0Temp, b=true, sel=exitTimer, out=nextS0);
    Mux(a=nextS1Temp, b=false, sel=exitTimer, out=nextS1);
    Mux(a=nextS2Temp, b=false, sel=exitTimer, out=nextS2);
    Mux(a=nextS3Temp, b=false, sel=exitTimer, out=nextS3);

    Or(a=state0, b=state3, out=xRedOr1);
    Or(a=state4, b=state5, out=xRedOr2);
    Or(a=state6, b=state7, out=xRedOr3);
    Or(a=state8, b=state9, out=xRedOr4);
    Or(a=xRedOr1, b=xRedOr2, out=xRedOr5);
    Or(a=xRedOr3, b=xRedOr4, out=xRedOr6);
    Or(a=xRedOr5, b=xRedOr6, out=xRedNormal);
    And(a=xRedNormal, b=PowerOn, out=X[2]);

    Or(a=state1, b=state3, out=xAmberOr);
    And(a=xAmberOr, b=PowerOn, out=X[1]);

    And(a=state2, b=PowerOn, out=X[0]);

    Or(a=state0, b=state1, out=zRedOr1);
    Or(a=state2, b=state3, out=zRedOr2);
    Or(a=state4, b=state7, out=zRedOr3);
    Or(a=state8, b=state9, out=zRedOr4);
    Or(a=zRedOr1, b=zRedOr2, out=zRedOr5);
    Or(a=zRedOr3, b=zRedOr4, out=zRedOr6);
    Or(a=zRedOr5, b=zRedOr6, out=zRedNormal);
    And(a=zRedNormal, b=PowerOn, out=Z[2]);

    Or(a=state5, b=state7, out=zAmberOr);
    And(a=zAmberOr, b=PowerOn, out=Z[1]);

    And(a=state6, b=PowerOn, out=Z[0]);

    Not(in=TimerMode, out=Wait);

    And(a=buttonLatched, b=PowerOn, out=ButtonPressed);

    Decoder(in[0]=timer0, in[1]=timer1, in[2]=timer2, in[3]=timer3,
            a=decA, b=decB, c=decC, d=decD, e=decE, f=decF, g=decG);

    And(a=decA, b=TimerMode, out=C[6]);
    And(a=decE, b=TimerMode, out=C[5]);
    And(a=decB, b=TimerMode, out=C[4]);
    And(a=decC, b=TimerMode, out=C[3]);
    And(a=decD, b=TimerMode, out=C[2]);
    And(a=decF, b=TimerMode, out=C[1]);
    And(a=decG, b=TimerMode, out=C[0]);
}