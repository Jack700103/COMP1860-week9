// ================================================
// Crossing Controller with Pedestrian Timer
// 简化版本 - 移除计时器寄存器，使用状态机直接控制
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    
    // --- 状态寄存器 (3位) ---
    // 状态编码: 
    // 000: 双红灯 (初始状态)
    // 001: X红黄灯
    // 010: X绿灯  
    // 011: X黄灯
    // 100: Z红黄灯
    // 101: Z绿灯
    // 110: Z黄灯
    // 111: 计时器模式
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 反相信号
    Not(in=state0, out=notState0);
    Not(in=state1, out=notState1);
    Not(in=state2, out=notState2);
    
    // --- 按钮检测和锁存 ---
    DFF(in=Button, out=buttonPrev);
    Not(in=buttonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=buttonRisingEdge);
    
    // 按钮锁存寄存器
    DFF(in=nextButtonLatched, out=buttonLatched);
    
    // --- 状态解码 ---
    
    // 状态000: 双红灯
    And(a=notState2, b=notState1, out=andS2S1000);
    And(a=andS2S1000, b=notState0, out=state000);
    
    // 状态001: X红黄灯
    And(a=notState2, b=notState1, out=andS2S1001);
    And(a=andS2S1001, b=state0, out=state001);
    
    // 状态010: X绿灯
    And(a=notState2, b=state1, out=andS2S1010);
    And(a=andS2S1010, b=notState0, out=state010);
    
    // 状态011: X黄灯
    And(a=notState2, b=state1, out=andS2S1011);
    And(a=andS2S1011, b=state0, out=state011);
    
    // 状态100: Z红黄灯
    And(a=state2, b=notState1, out=andS2S1100);
    And(a=andS2S1100, b=notState0, out=state100);
    
    // 状态101: Z绿灯
    And(a=state2, b=notState1, out=andS2S1101);
    And(a=andS2S1101, b=state0, out=state101);
    
    // 状态110: Z黄灯
    And(a=state2, b=state1, out=andS2S1110);
    And(a=andS2S1110, b=notState0, out=state110);
    
    // 状态111: 计时器模式
    And(a=state2, b=state1, out=andS2S1111);
    And(a=andS2S1111, b=state0, out=state111);
    
    // --- 计时器逻辑（简化版）---
    // 使用一个简单的计数器来控制计时器模式的持续时间
    // 这里使用2位计数器，让计时器模式持续4个时钟周期
    
    // 计时器计数器
    DFF(in=nextTimerCount0, out=timerCount0);
    DFF(in=nextTimerCount1, out=timerCount1);
    
    // 计时器计数器逻辑
    // 当进入计时器模式时复位为0，然后每个时钟周期递增
    
    // 进入计时器模式的条件
    And(a=buttonLatched, b=state110, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);
    
    // 计时器计数器的下一个值
    // 如果进入计时器模式，复位为00
    // 否则在计时器模式中递增
    
    // 递增逻辑：timerCount + 1
    Not(in=timerCount0, out=notTimerCount0);
    And(a=timerCount1, b=timerCount0, out=timerCountMax); // 11 -> 最大
    
    // 低位：timerCount0 翻转
    And(a=state111, b=notTimerCount0, out=incTimerCount0);
    Or(a=enterTimer, b=incTimerCount0, out=nextTimerCount0);
    
    // 高位：当低位为1时翻转
    Xor(a=timerCount1, b=timerCount0, out=nextTimerCount1Temp);
    And(a=state111, b=nextTimerCount1Temp, out=nextTimerCount1);
    
    // 计时器结束条件：计数器达到最大值（11）
    // 这样计时器模式会持续4个时钟周期（00, 01, 10, 11）
    And(a=timerCount1, b=timerCount0, out=timerDone);
    
    // 退出计时器模式条件
    And(a=state111, b=timerDone, out=exitTimer);
    
    // --- 状态转移逻辑 ---
    
    // 正常状态转移序列：000->001->010->011->100->101->110->000
    
    // 状态0的下一状态位
    // 当状态为000, 011, 110时，下一状态的state0=1
    Or(a=state000, b=state011, out=orState01);
    Or(a=orState01, b=state110, out=orState02);
    And(a=orState02, b=PowerOn, out=nextState0Base);
    
    // 状态1的下一状态位
    // 当状态为001, 010, 100, 101时，下一状态的state1=1
    Or(a=state001, b=state010, out=orState11);
    Or(a=state100, b=state101, out=orState12);
    Or(a=orState11, b=orState12, out=orState13);
    And(a=orState13, b=PowerOn, out=nextState1Base);
    
    // 状态2的下一状态位
    // 当状态为100, 101, 110时，下一状态的state2=1
    Or(a=state100, b=state101, out=orState21);
    Or(a=orState21, b=state110, out=orState22);
    And(a=orState22, b=PowerOn, out=nextState2Base);
    
    // 应用计时器模式
    // 如果进入计时器模式，下一状态为111
    Mux(a=nextState0Base, b=true, sel=enterTimer, out=nextState0Temp);
    Mux(a=nextState1Base, b=true, sel=enterTimer, out=nextState1Temp);
    Mux(a=nextState2Base, b=true, sel=enterTimer, out=nextState2Temp);
    
    // 如果退出计时器模式，下一状态为000
    Mux(a=nextState0Temp, b=false, sel=exitTimer, out=nextState0);
    Mux(a=nextState1Temp, b=false, sel=exitTimer, out=nextState1);
    Mux(a=nextState2Temp, b=false, sel=exitTimer, out=nextState2);
    
    // --- 按钮锁存逻辑 ---
    // 按钮按下时锁存，计时器模式结束时清除
    Or(a=buttonRisingEdge, b=buttonLatched, out=buttonLatchedOr);
    Not(in=state111, out=notState111);
    And(a=buttonLatchedOr, b=notState111, out=nextButtonLatched);
    
    // --- 交通灯输出逻辑 ---
    
    // X灯输出: X[2]=红, X[1]=黄, X[0]=绿
    // X红灯亮当：状态000, 100, 101, 110, 111
    Or(a=state000, b=state100, out=xRedOr1);
    Or(a=xRedOr1, b=state101, out=xRedOr2);
    Or(a=xRedOr2, b=state110, out=xRedOr3);
    Or(a=xRedOr3, b=state111, out=xRedOr4);
    And(a=xRedOr4, b=PowerOn, out=X[2]);
    
    // X黄灯亮当：状态001或011
    Or(a=state001, b=state011, out=xAmberOr);
    And(a=xAmberOr, b=PowerOn, out=X[1]);
    
    // X绿灯亮当：状态010
    And(a=state010, b=PowerOn, out=X[0]);
    
    // Z灯输出: Z[2]=红, Z[1]=黄, Z[0]=绿
    // Z红灯亮当：状态000, 001, 010, 011, 111
    Or(a=state000, b=state001, out=zRedOr1);
    Or(a=zRedOr1, b=state010, out=zRedOr2);
    Or(a=zRedOr2, b=state011, out=zRedOr3);
    Or(a=zRedOr3, b=state111, out=zRedOr4);
    And(a=zRedOr4, b=PowerOn, out=Z[2]);
    
    // Z黄灯亮当：状态100或110
    Or(a=state100, b=state110, out=zAmberOr);
    And(a=zAmberOr, b=PowerOn, out=Z[1]);
    
    // Z绿灯亮当：状态101
    And(a=state101, b=PowerOn, out=Z[0]);
    
    // --- Wait信号 ---
    // Wait=1表示交通灯在正常序列中，不能过街
    // Wait=0表示在计时器模式，可以过街
    Not(in=state111, out=Wait);
    
    // --- ButtonPressed输出 ---
    And(a=buttonLatched, b=PowerOn, out=ButtonPressed);
    
    // --- 7段数码管输出 ---
    // 根据8.jpg的段位顺序: 
    // a=下横段线在底端, e=上横段线在顶端, b=中横段线在中间
    // d=左上竖段线在左上端, f=右上竖段线在右上端
    // g=左下竖段线在左下端, c=右下竖段线在右下端
    // 输出顺序: C[6]=a, C[5]=e, C[4]=b, C[3]=c, C[2]=d, C[1]=f, C[0]=g
    
    // 在计时器模式下根据计时器计数器值显示不同的数字
    // 计时器计数器值: 00, 01, 10, 11 对应显示 3, 2, 1, 0
    
    // 解码计时器计数器值到7段显示
    
    // 数字3的段码: a,b,c,d,g亮 = 1111001
    // 数字2的段码: a,b,d,e,g亮 = 1101101
    // 数字1的段码: b,c亮 = 0110000
    // 数字0的段码: a,b,c,d,e,f亮 = 1111110
    
    // 根据计时器计数器值选择显示的数字
    
    // 段a (C[6]): 显示0,2,3时亮
    // timerCount=00(显示3): 亮
    // timerCount=01(显示2): 亮  
    // timerCount=10(显示1): 灭
    // timerCount=11(显示0): 亮
    And(a=notTimerCount1, b=notTimerCount0, out=show3); // 00
    And(a=notTimerCount1, b=timerCount0, out=show2);    // 01
    And(a=timerCount1, b=notTimerCount0, out=show1);    // 10
    And(a=timerCount1, b=timerCount0, out=show0);       // 11
    
    Or(a=show3, b=show2, out=segAOr1);
    Or(a=segAOr1, b=show0, out=segAOr2);
    And(a=segAOr2, b=state111, out=C[6]);
    
    // 段e (C[5]): 显示0,2时亮
    Or(a=show2, b=show0, out=segEOr);
    And(a=segEOr, b=state111, out=C[5]);
    
    // 段b (C[4]): 显示0,1,2,3时都亮
    Or(a=show3, b=show2, out=segBOr1);
    Or(a=show1, b=show0, out=segBOr2);
    Or(a=segBOr1, b=segBOr2, out=segBOr3);
    And(a=segBOr3, b=state111, out=C[4]);
    
    // 段c (C[3]): 显示0,1,3时亮
    Or(a=show3, b=show1, out=segCOr1);
    Or(a=segCOr1, b=show0, out=segCOr2);
    And(a=segCOr2, b=state111, out=C[3]);
    
    Or(a=show3, b=show2, out=segDOr1);
    Or(a=segDOr1, b=show0, out=segDOr2);
    And(a=segDOr2, b=state111, out=C[2]);
    
    And(a=show0, b=state111, out=C[1]);
    
    Or(a=show3, b=show2, out=segGOr);
    And(a=segGOr, b=state111, out=C[0]);
}