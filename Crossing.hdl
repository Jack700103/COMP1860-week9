CHIP Crossing {
    IN  PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    //======================================================================
    // 状态寄存器：
    //   crossActive    : 当前是否处在“行人放行+倒计时”阶段
    //   buttonLatched  : 自上次完成一次过街后到现在，是否有人按过按钮
    //======================================================================
    DFF(in=nextCrossActive,   out=crossActive);
    DFF(in=nextButtonLatched, out=buttonLatched);

    //======================================================================
    // 1) 交通灯控制：在行人过街期间关掉 JunctionController 的电源，
    //    这样它保持在 RED 状态；其它时间正常工作。
    //======================================================================
    Not(in=crossActive, out=notCrossActive);
    And(a=PowerOn, b=notCrossActive, out=powerForJunc);

    // 不能使用内部总线下标，所以把 X、Z 拆成单比特信号
    JunctionController(
        PowerOn=powerForJunc,
        X[0]=Xj0, X[1]=Xj1, X[2]=Xj2,
        Z[0]=Zj0, Z[1]=Zj1, Z[2]=Zj2
    );

    //======================================================================
    // 2) 检测 “X 和 Z 都是红灯”：X == 100 且 Z == 100
    //======================================================================
    // X 是否为 RED = 1 0 0
    Not(in=Xj1, out=notX1);
    Not(in=Xj0, out=notX0);
    And(a=Xj2, b=notX1, out=xTemp1);
    And(a=xTemp1, b=notX0, out=XisRed);

    // Z 是否为 RED = 1 0 0
    Not(in=Zj1, out=notZ1);
    Not(in=Zj0, out=notZ0);
    And(a=Zj2, b=notZ1, out=zTemp1);
    And(a=zTemp1, b=notZ0, out=ZisRed);

    And(a=XisRed, b=ZisRed, out=bothRed);

    //======================================================================
    // 3) 计数器：在 crossActive=1 时递减，从 9 数到 0。
    //    reset 在“开始过街”的那个时钟周期拉高一次，把计数器置 9。
    //======================================================================
    CounterDec(
        dec=crossActive,
        reset=counterReset,
        out[0]=count0,
        out[1]=count1,
        out[2]=count2,
        out[3]=count3
    );

    // 4 bit → 7 段译码
    Decoder(
        in[0]=count0, in[1]=count1, in[2]=count2, in[3]=count3,
        a=deca, b=decb, c=decc, d=decd, e=dece, f=decf, g=decg
    );

    //======================================================================
    // 4) 检测计数结束：count == 0000 且 crossActive=1
    //======================================================================
    Or(a=count0, b=count1, out=or01);
    Or(a=count2, b=count3, out=or23);
    Or(a=or01,   b=or23,   out=anyBit);      // 任一位为 1，则 anyBit=1
    Not(in=anyBit, out=countIsZero);         // 全 0 时 countIsZero=1

    And(a=crossActive, b=countIsZero, out=timerDone);

    //======================================================================
    // 5) 按钮锁存：
    //    有人按按钮就置位（Button=1），一直保持到本次过街计时结束。
    //======================================================================
    Or(a=Button, b=buttonLatched, out=latchedOrButton);
    Not(in=timerDone, out=notTimerDone);
    And(a=latchedOrButton, b=notTimerDone, out=nextButtonLatched);

    //======================================================================
    // 6) 过街状态 crossActive：
    //    - 在 “X、Z 都红” 且 已有人按过按钮 时，且当前不在过街，
    //      进入过街 shouldStart=1；
    //    - 进入后保持 crossActive=1，直到 timerDone=1。
    //======================================================================
    Not(in=crossActive, out=notCrossActive2);
    And(a=bothRed, b=buttonLatched, out=redAndRequest);
    And(a=redAndRequest, b=notCrossActive2, out=shouldStart);

    And(a=crossActive, b=notTimerDone, out=stayActive);
    Or(a=stayActive, b=shouldStart, out=nextCrossActive);

    // 计数器 reset：只在 shouldStart 的那个周期拉高
    Or(a=false, b=shouldStart, out=counterReset);

    //======================================================================
    // 7) 输出信号
    //======================================================================

    // ButtonPressed：表示当前这一轮是否已经有人按过
    Or(a=buttonLatched, b=false, out=ButtonPressed);

    // Wait：只有在真正允许过街（crossActive=1）时为 0，其余时间为 1
    Not(in=crossActive, out=Wait);

    // C：只在过街倒计时时显示数字，其它时间全灭
    Mux(a=false, b=deca, sel=crossActive, out=C[0]);
    Mux(a=false, b=decb, sel=crossActive, out=C[1]);
    Mux(a=false, b=decc, sel=crossActive, out=C[2]);
    Mux(a=false, b=decd, sel=crossActive, out=C[3]);
    Mux(a=false, b=dece, sel=crossActive, out=C[4]);
    Mux(a=false, b=decf, sel=crossActive, out=C[5]);
    Mux(a=false, b=decg, sel=crossActive, out=C[6]);

    // 把 JunctionController 的灯状态直接透传出去
    Or(a=Xj0, b=false, out=X[0]);
    Or(a=Xj1, b=false, out=X[1]);
    Or(a=Xj2, b=false, out=X[2]);

    Or(a=Zj0, b=false, out=Z[0]);
    Or(a=Zj1, b=false, out=Z[1]);
    Or(a=Zj2, b=false, out=Z[2]);
}
