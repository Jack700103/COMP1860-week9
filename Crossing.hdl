// ================================================
// Crossing Controller with Pedestrian Timer
// 使用JunctionController作为基础状态机，添加按钮检测和计时器功能
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    
    // --- 核心状态机：使用JunctionController ---
    JunctionController(PowerOn=PowerOn, X=normalX[3], Z=normalZ[3]);
    
    // --- 状态寄存器扩展：用于计时器控制 ---
    // S4: 计时器模式标志 (1=计时器运行, 0=正常模式)
    DFF(in=nextS4, out=S4);
    
    // 获取反相信号
    Not(in=S4, out=notS4);
    
    // --- 按钮检测和锁存逻辑 ---
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRisingEdge);
    
    // ButtonPressed寄存器：按钮按下时置位，计时器结束后清除
    DFF(in=nextBP, out=ButtonPressedReg);
    
    // 按钮锁存逻辑：按钮按下或保持，直到计时器结束
    Or(a=ButtonRisingEdge, b=ButtonPressedReg, out=BPOr);
    And(a=BPOr, b=notS4, out=BPAnd); // 只在非计时器模式下保持
    Or(a=BPAnd, b=ButtonRisingEdge, out=nextBPTemp);
    And(a=nextBPTemp, b=PowerOn, out=nextBP);
    
    // 最终ButtonPressed输出
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
    
    // --- 计时器控制逻辑 ---
    // 计时器启动条件：按钮已按下且处于双红灯状态
    // 检查双红灯状态：X和Z都是100（红灯）
    And(a=normalX[2], b=normalZ[2], out=bothRed1);
    And(a=bothRed1, b=normalX[1], out=bothRed2);
    Not(in=normalX[1], out=notNormalX1);
    And(a=bothRed2, b=notNormalX1, out=bothRed3);
    And(a=bothRed3, b=normalZ[1], out=bothRed4);
    Not(in=normalZ[1], out=notNormalZ1);
    And(a=bothRed4, b=notNormalZ1, out=bothRed);
    
    // 检查Z刚完成周期：从Z黄灯(010)变为双红
    // 我们需要记住上一个状态，这里简化：当双红且按钮按下时启动计时器
    And(a=ButtonPressedReg, b=bothRed, out=startTimerCond);
    And(a=startTimerCond, b=PowerOn, out=startTimer);
    
    // 计时器模块：CounterDec从9倒数到0
    // 计时器使能：计时器模式且计时器不为0时递减
    // 计时器复位：启动计时器时复位到9
    CounterDec(dec=decTimer, reset=resetTimer, out=TimerOut[4]);
    
    // 检查计时器是否为0（0000）
    Or(a=TimerOut[0], b=TimerOut[1], out=orTimer01);
    Or(a=TimerOut[2], b=TimerOut[3], out=orTimer23);
    Or(a=orTimer01, b=orTimer23, out=TimerNotZero);
    Not(in=TimerNotZero, out=TimerZero);
    
    // 计时器模式控制
    // 进入计时器模式：startTimer为1
    // 退出计时器模式：计时器为0
    And(a=S4, b=TimerZero, out=exitTimer);
    Or(a=S4, b=startTimer, out=stayOrStart);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrStart, b=notExit, out=nextS4);
    
    // 计时器递减使能：计时器模式且计时器不为0
    And(a=S4, b=TimerNotZero, out=decTimer);
    
    // 计时器复位：启动计时器时复位
    Mux(a=false, b=true, sel=startTimer, out=resetTimer);
    
    // --- Wait信号：计时器模式时为0，否则为1 ---
    Not(in=S4, out=Wait);
    
    // --- 交通灯输出：计时器模式下强制双红灯，否则使用JunctionController输出 ---
    Mux(a=normalX[2], b=true, sel=S4, out=X[2]);
    Mux(a=normalX[1], b=false, sel=S4, out=X[1]);
    Mux(a=normalX[0], b=false, sel=S4, out=X[0]);
    
    Mux(a=normalZ[2], b=true, sel=S4, out=Z[2]);
    Mux(a=normalZ[1], b=false, sel=S4, out=Z[1]);
    Mux(a=normalZ[0], b=false, sel=S4, out=Z[0]);
    
    // --- 7段数码管输出：使用Decoder芯片 ---
    // 注意：TimerOut是4位输出，Decoder需要4位输入
    Decoder(in=TimerOut, a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG);
    
    // 仅当计时器模式时输出数码管信号，否则全0
    And(a=segA, b=S4, out=C[6]);
    And(a=segB, b=S4, out=C[5]);
    And(a=segC, b=S4, out=C[4]);
    And(a=segD, b=S4, out=C[3]);
    And(a=segE, b=S4, out=C[2]);
    And(a=segF, b=S4, out=C[1]);
    And(a=segG, b=S4, out=C[0]);
}