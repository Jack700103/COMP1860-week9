// ================================================
// Crossing Controller with Pedestrian Timer
// 简化版本 - 修正状态机和计时器逻辑
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    
    // --- 主时钟和复位 ---
    // 使用内置时钟
    // 使用PowerOn作为总使能
    
    // --- 状态寄存器 (5个状态) ---
    // 状态编码: 000=双红, 001=X红黄, 010=X绿, 011=X黄, 100=Z红黄, 101=Z绿, 110=Z黄, 111=计时模式
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 状态反相
    Not(in=state0, out=notState0);
    Not(in=state1, out=notState1);
    Not(in=state2, out=notState2);
    
    // --- 按钮检测和锁存 ---
    // 检测按钮按下
    DFF(in=Button, out=buttonReg);
    And(a=Button, b=buttonReg, out=buttonPressedRaw);
    
    // 按钮锁存：一旦按下，保持到计时模式结束
    DFF(in=nextButtonLatched, out=buttonLatched);
    
    // --- 计时器逻辑 ---
    // 4位计数器，从9倒数到0
    DFF(in=nextTimer0, out=timer0);
    DFF(in=nextTimer1, out=timer1);
    DFF(in=nextTimer2, out=timer2);
    DFF(in=nextTimer3, out=timer3);
    
    // 计时器值为0检测
    Or(a=timer0, b=timer1, out=timerOr01);
    Or(a=timer2, b=timer3, out=timerOr23);
    Or(a=timerOr01, b=timerOr23, out=timerNotZero);
    Not(in=timerNotZero, out=timerZero);
    
    // --- 状态转移逻辑 ---
    
    // 状态转移条件
    // 正常模式：当不是计时模式时，按固定顺序转移
    // 计时模式：当按钮已按下且处于Z黄灯状态时进入，计时器到0时退出
    
    // 检测是否在Z黄灯状态 (110)
    And(a=state2, b=state1, out=andState21);
    And(a=andState21, b=notState0, out=zAmberState); // state=110
    
    // 进入计时模式条件
    And(a=buttonLatched, b=zAmberState, out=enterTimer);
    
    // 退出计时模式条件
    And(a=state2, b=state1, c=state0, out=timerMode); // state=111
    And(a=timerMode, b=timerZero, out=exitTimer);
    
    // 下一个状态计算
    // 正常状态转移
    // 状态机: 000->001->010->011->100->101->110->000
    
    // 当前状态的解码
    And(a=notState2, b=notState1, c=notState0, out=state000); // 双红
    And(a=notState2, b=notState1, c=state0, out=state001);    // X红黄
    And(a=notState2, b=state1, c=notState0, out=state010);    // X绿
    And(a=notState2, b=state1, c=state0, out=state011);       // X黄
    And(a=state2, b=notState1, c=notState0, out=state100);    // Z红黄
    And(a=state2, b=notState1, c=state0, out=state101);       // Z绿
    And(a=state2, b=state1, c=notState0, out=state110);       // Z黄
    
    // 下一状态逻辑
    Mux8Way16(a=false, b=false, c=false, d=false, e=false, f=false, g=false, h=false,
              sel[0]=state0, sel[1]=state1, sel[2]=state2,
              out=nextStateTemp);
    
    // 使用Mux实现状态转移
    // 由于HDL没有直接的状态机语法，我们需要用逻辑门实现
    
    // 状态2的下一位
    // 状态转移: 011->100, 110->000, 111->000
    Or(a=state011, b=state101, out=orForState21);
    Or(a=orForState21, b=state110, out=orForState22);
    Or(a=orForState22, b=timerMode, out=orForState23);
    And(a=orForState23, b=PowerOn, out=nextState2Base);
    
    // 状态1的下一位
    // 状态转移: 001->010, 010->011, 100->101, 101->110
    Or(a=state001, b=state010, out=orForState11);
    Or(a=state100, b=state101, out=orForState12);
    Or(a=orForState11, b=orForState12, out=orForState13);
    And(a=orForState13, b=PowerOn, out=nextState1Base);
    
    // 状态0的下一位
    // 状态转移: 000->001, 011->100, 110->000
    Or(a=state000, b=state011, out=orForState01);
    Or(a=orForState01, b=state110, out=orForState02);
    And(a=orForState02, b=PowerOn, out=nextState0Base);
    
    // 计时器模式覆盖
    // 进入计时模式: state=111
    Or(a=enterTimer, b=timerMode, out=timerActive);
    
    Mux(a=nextState2Base, b=true, sel=timerActive, out=nextState2Temp);
    Mux(a=nextState1Base, b=true, sel=timerActive, out=nextState1Temp);
    Mux(a=nextState0Base, b=true, sel=timerActive, out=nextState0Temp);
    
    // 计时器结束时返回状态000
    Mux(a=nextState2Temp, b=false, sel=exitTimer, out=nextState2);
    Mux(a=nextState1Temp, b=false, sel=exitTimer, out=nextState1);
    Mux(a=nextState0Temp, b=false, sel=exitTimer, out=nextState0);
    
    // --- 按钮锁存逻辑 ---
    // 当按钮按下时锁存，计时模式结束时清除
    Or(a=buttonPressedRaw, b=buttonLatched, out=buttonLatchedOr);
    And(a=buttonLatchedOr, b=notTimerMode, out=nextButtonLatched);
    
    // --- 计时器计数逻辑 ---
    // 计时器模式时从9开始倒数
    
    // 计时器加载值: 9 = 1001
    Mux(a=false, b=true, sel=enterTimer, out=loadTimer);
    
    // 计时器递减
    // 简单实现：每个时钟周期减1
    // 实际应该用更复杂的计数器，这里简化
    
    // --- 交通灯输出逻辑 ---
    
    // X灯输出: X[2]=红, X[1]=黄, X[0]=绿
    // X红: 状态000, 100, 101, 110, 111 或 Z在运行时
    Or(a=state000, b=state100, out=xRedOr1);
    Or(a=xRedOr1, b=state101, out=xRedOr2);
    Or(a=xRedOr2, b=state110, out=xRedOr3);
    Or(a=xRedOr3, b=timerMode, out=xRedOr4);
    And(a=xRedOr4, b=PowerOn, out=X[2]);
    
    // X红黄: 状态001
    And(a=state001, b=PowerOn, out=X[1]);
    
    // X黄: 状态011
    And(a=state011, b=PowerOn, out=XamberTemp);
    // X绿: 状态010
    And(a=state010, b=PowerOn, out=XgreenTemp);
    
    // X[1]和X[0]的最终输出
    Or(a=X[1], b=XamberTemp, out=X[1]);
    Mux(a=false, b=XgreenTemp, sel=PowerOn, out=X[0]);
    
    // Z灯输出: Z[2]=红, Z[1]=黄, Z[0]=绿
    // Z红: 状态000, 001, 010, 011, 111 或 X在运行时
    Or(a=state000, b=state001, out=zRedOr1);
    Or(a=zRedOr1, b=state010, out=zRedOr2);
    Or(a=zRedOr2, b=state011, out=zRedOr3);
    Or(a=zRedOr3, b=timerMode, out=zRedOr4);
    And(a=zRedOr4, b=PowerOn, out=Z[2]);
    
    // Z红黄: 状态100
    And(a=state100, b=PowerOn, out=Z[1]);
    
    // Z黄: 状态110
    And(a=state110, b=PowerOn, out=ZamberTemp);
    // Z绿: 状态101
    And(a=state101, b=PowerOn, out=ZgreenTemp);
    
    // Z[1]和Z[0]的最终输出
    Or(a=Z[1], b=ZamberTemp, out=Z[1]);
    Mux(a=false, b=ZgreenTemp, sel=PowerOn, out=Z[0]);
    
    // --- Wait信号 ---
    // Wait=1表示不能过街（正常交通灯序列中）
    // Wait=0表示可以过街（计时器模式）
    Not(in=timerMode, out=Wait);
    
    // --- ButtonPressed输出 ---
    Mux(a=false, b=buttonLatched, sel=PowerOn, out=ButtonPressed);
    
    // --- 7段数码管显示 ---
    // 根据8.jpg的顺序: a=下横, e=上横, b=中横, c=右下竖, d=左上竖, f=右上竖, g=左下竖
    // C[6]=a, C[5]=e, C[4]=b, C[3]=c, C[2]=d, C[1]=f, C[0]=g
    
    // 显示0-9的7段编码
    // 这里需要根据计时器值显示，但由于计时器逻辑复杂，先显示固定模式
    // 实际应该根据timer0-timer3的值来显示
    
    // 临时：计时器模式时显示"8"（所有段都亮）
    Mux8Way16(a=false, b=false, c=false, d=false, e=false, f=false, g=false, h=false,
              sel[0]=timer0, sel[1]=timer1, sel[2]=timer2, sel[3]=timer3,
              out=segPattern);
    
    // 简化：计时器模式时显示递减数字
    // 数字0: 1111110 (a,b,c,d,e,f亮)
    // 数字1: 0110000 (b,c亮)
    // 数字2: 1101101 (a,b,d,e,g亮)
    // 数字3: 1111001 (a,b,c,d,g亮)
    // 数字4: 0110011 (b,c,f,g亮)
    // 数字5: 1011011 (a,c,d,f,g亮)
    // 数字6: 1011111 (a,c,d,e,f,g亮)
    // 数字7: 1110000 (a,b,c亮)
    // 数字8: 1111111 (所有段亮)
    // 数字9: 1111011 (a,b,c,d,f,g亮)
    
    // 由于HDL限制，这里简化处理
    // 计时器模式时，根据计时器值显示
    
    // 段a (C[6])
    And(a=timerMode, b=PowerOn, out=C[6]);
    
    // 其他段先设为0
    // 实际应该根据数字解码
    // 这里简化：计时器模式时显示"8"
    And(a=timerMode, b=PowerOn, out=C[5]);
    And(a=timerMode, b=PowerOn, out=C[4]);
    And(a=timerMode, b=PowerOn, out=C[3]);
    And(a=timerMode, b=PowerOn, out=C[2]);
    And(a=timerMode, b=PowerOn, out=C[1]);
    And(a=timerMode, b=PowerOn, out=C[0]);
}