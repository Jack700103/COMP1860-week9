CHIP Crossing {
    IN  PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    //======================================================================
    // 状态寄存器：
    //  crossActive    = 当前是否处在“行人放行+倒计时”阶段
    //  buttonLatched  = 自上次完成一次过街后到现在，是否有人按过按钮
    //======================================================================
    DFF(in=nextCrossActive,  out=crossActive);
    DFF(in=nextButtonLatched,out=buttonLatched);

    //======================================================================
    // 1) 交通灯控制：在行人过街期间关掉 JunctionController 的电源，
    //    这样它保持在 RED 状态；其它时间正常工作。
    //======================================================================
    Not(in=crossActive, out=notCrossActive);
    And(a=PowerOn, b=notCrossActive, out=powerForJunc);

    JunctionController(PowerOn=powerForJunc, X=Xj, Z=Zj);

    //======================================================================
    // 2) 检测 “X 和 Z 都是红灯”：X == 100 且 Z == 100
    //======================================================================
    // X 是否为 RED = 1 0 0
    Not(in=Xj[1], out=notX1);
    Not(in=Xj[0], out=notX0);
    And(a=Xj[2], b=notX1, out=xTemp1);
    And(a=xTemp1, b=notX0, out=XisRed);

    // Z 是否为 RED = 1 0 0
    Not(in=Zj[1], out=notZ1);
    Not(in=Zj[0], out=notZ0);
    And(a=Zj[2], b=notZ1, out=zTemp1);
    And(a=zTemp1, b=notZ0, out=ZisRed);

    And(a=XisRed, b=ZisRed, out=bothRed);

    //======================================================================
    // 3) 计数器：在 crossActive=1 时递减，从 9 数到 0。
    //    reset 在“开始过街”的那个时钟周期拉高一次，把计数器置 9。
    //======================================================================
    CounterDec(dec=crossActive, reset=counterReset, out=counter);

    // 4bit → 7 段
    Decoder(in=counter, a=deca, b=decb, c=decc, d=decd, e=dece, f=decf, g=decg);

    //======================================================================
    // 4) 检测计数结束：counter == 0000 且 crossActive=1
    //======================================================================
    Or(a=counter[0], b=counter[1], out=or01);
    Or(a=counter[2], b=counter[3], out=or23);
    Or(a=or01, b=or23, out=anyBit);       // 任一位为 1，则 anyBit=1
    Not(in=anyBit, out=countIsZero);      // all zero 时 countIsZero=1

    And(a=crossActive, b=countIsZero, out=timerDone);

    //======================================================================
    // 5) 按钮锁存：
    //    - 有人按按钮就置位（Button=1）
    //    - 一直保持为 1，直到本次过街倒计时结束 timerDone=1
    //======================================================================
    Or(a=Button, b=buttonLatched, out=latchedOrButton);
    Not(in=timerDone, out=notTimerDone);
    And(a=latchedOrButton, b=notTimerDone, out=nextButtonLatched);

    //======================================================================
    // 6) 过街状态 crossActive：
    //    - 在 “X、Z 都红” 且 已有人按过按钮（buttonLatched=1）时，
    //      若当前不在过街，则进入过街 shouldStart=1
    //    - 进入后保持 crossActive=1，直到 timerDone=1
    //======================================================================
    Not(in=crossActive, out=notCrossActive2);
    And(a=bothRed, b=buttonLatched, out=redAndRequest);
    And(a=redAndRequest, b=notCrossActive2, out=shouldStart);

    And(a=crossActive, b=notTimerDone, out=stayActive);
    Or(a=stayActive, b=shouldStart, out=nextCrossActive);

    // 计数器 reset：只在 shouldStart 的那个周期拉高
    Or(a=false, b=shouldStart, out=counterReset);

    //======================================================================
    // 7) 输出信号
    //======================================================================

    // ButtonPressed：表示当前这一轮是否有人按过
    Or(a=buttonLatched, b=false, out=ButtonPressed);

    // Wait：只有在真正允许过街（crossActive=1）时为 0，其余时间为 1
    Not(in=crossActive, out=Wait);

    // C：只在过街倒计时时显示数字，其它时间全灭
    Mux(a=false, b=deca, sel=crossActive, out=C[0]);
    Mux(a=false, b=decb, sel=crossActive, out=C[1]);
    Mux(a=false, b=decc, sel=crossActive, out=C[2]);
    Mux(a=false, b=decd, sel=crossActive, out=C[3]);
    Mux(a=false, b=dece, sel=crossActive, out=C[4]);
    Mux(a=false, b=decf, sel=crossActive, out=C[5]);
    Mux(a=false, b=decg, sel=crossActive, out=C[6]);

    // 把 JunctionController 的灯状态直接透传出去
    Or(a=Xj[0], b=false, out=X[0]);
    Or(a=Xj[1], b=false, out=X[1]);
    Or(a=Xj[2], b=false, out=X[2]);

    Or(a=Zj[0], b=false, out=Z[0]);
    Or(a=Zj[1], b=false, out=Z[1]);
    Or(a=Zj[2], b=false, out=Z[2]);
}
