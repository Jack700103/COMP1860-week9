CHIP Crossing {
    IN  PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    // 状态寄存器：s1 s0 组成 3 个状态
    // state0: 正常运行、未请求
    // state1: 已按键，等待两个方向都红灯
    // state2: 行人过街计时
    DFF(in=nexts0, out=s0);
    DFF(in=nexts1, out=s1);

    // 记住“有人按过按钮”的标志
    DFF(in=nextbuttonFlag, out=buttonFlag);

    // 状态译码
    Not(in=s0, out=nots0);
    Not(in=s1, out=nots1);
    And(a=nots0, b=nots1, out=state0);   // 00
    And(a=s0,    b=nots1, out=state1);   // 01
    And(a=nots0, b=s1,    out=state2);   // 10

    // 交通灯控制器（两方向正常轮转）
    JunctionController(
        PowerOn = PowerOn,
        X[0]    = Xjunc0,
        X[1]    = Xjunc1,
        X[2]    = Xjunc2,
        Z[0]    = Zjunc0,
        Z[1]    = Zjunc1,
        Z[2]    = Zjunc2
    );

    // 把 JunctionController 的输出打一拍，用于检测“红灯”
    DFF(in=Xjunc0, out=Xtemp0);
    DFF(in=Xjunc1, out=Xtemp1);
    DFF(in=Xjunc2, out=Xtemp2);

    DFF(in=Zjunc0, out=Ztemp0);
    DFF(in=Zjunc1, out=Ztemp1);
    DFF(in=Zjunc2, out=Ztemp2);

    // 判断 X 是否为红灯：X = 100
    Not(in=Xtemp1, out=notXtemp1);
    Not(in=Xtemp0, out=notXtemp0);
    And(a=Xtemp2,    b=notXtemp1, out=XisRedPart);
    And(a=XisRedPart,b=notXtemp0, out=XisRed);

    // 判断 Z 是否为红灯：Z = 100
    Not(in=Ztemp1, out=notZtemp1);
    Not(in=Ztemp0, out=notZtemp0);
    And(a=Ztemp2,    b=notZtemp1, out=ZisRedPart);
    And(a=ZisRedPart,b=notZtemp0, out=ZisRed);

    // 两个方向都红灯，说明一轮车流周期结束
    And(a=XisRed, b=ZisRed, out=cycleComplete);

    // 按钮逻辑：只有在 state0（完全空闲）时，按键才会被记住
    And(a=state0, b=Button,    out=setButtonFlag);
    And(a=state2, b=timerDone, out=clearButtonFlag);

    Or(a=setButtonFlag, b=buttonFlag, out=buttonFlagBeforeClear);

    Not(in=clearButtonFlag, out=notClearButtonFlag);
    And(a=buttonFlagBeforeClear, b=notClearButtonFlag, out=buttonFlagTemp);

    // 断电时清零 buttonFlag
    Not(in=PowerOn, out=notPowerOn);
    Mux(a=buttonFlagTemp, b=false, sel=notPowerOn, out=nextbuttonFlag);

    // 输出“ButtonPressed” = 当前是否有有效的过街请求
    Or(a=buttonFlag, b=false, out=ButtonPressed);

    // **关键修正**：Wait 只在 state1 高电平（已经按键但还不能过）
    Or(a=state1, b=false, out=Wait);

    // state2（行人过街）时，强制两方向都红灯；否则正常跟随路口控制器
    Mux(a=Xtemp0, b=false, sel=state2, out=X[0]); // GREEN
    Mux(a=Xtemp1, b=false, sel=state2, out=X[1]); // AMBER
    Mux(a=Xtemp2, b=true,  sel=state2, out=X[2]); // RED

    Mux(a=Ztemp0, b=false, sel=state2, out=Z[0]);
    Mux(a=Ztemp1, b=false, sel=state2, out=Z[1]);
    Mux(a=Ztemp2, b=true,  sel=state2, out=Z[2]);

    // 计时器：state2 时递减计数，其他时候复位
    Not(in=state2, out=notState2);
    Or(a=notPowerOn, b=notState2, out=timerReset);

    CounterDec(
        dec    = state2,
        reset  = timerReset,
        out[0] = count0,
        out[1] = count1,
        out[2] = count2,
        out[3] = count3
    );

    // 计数器是否已经减到 0
    Or(a=count0, b=count1, out=anyBit01);
    Or(a=count2, b=count3, out=anyBit23);
    Or(a=anyBit01, b=anyBit23, out=anyBitSet);
    Not(in=anyBitSet, out=timerDone);

    // 7 段译码，显示当前倒计时
    Decoder(
        in[0] = count0,
        in[1] = count1,
        in[2] = count2,
        in[3] = count3,
        a     = deca,
        b     = decb,
        c     = decc,
        d     = decd,
        e     = dece,
        f     = decf,
        g     = decg
    );

    // 只在 state2 时点亮数码管，否则全部熄灭
    Mux(a=deca, b=false, sel=state2, out=C[0]);
    Mux(a=decb, b=false, sel=state2, out=C[1]);
    Mux(a=decc, b=false, sel=state2, out=C[2]);
    Mux(a=decd, b=false, sel=state2, out=C[3]);
    Mux(a=dece, b=false, sel=state2, out=C[4]);
    Mux(a=decf, b=false, sel=state2, out=C[5]);
    Mux(a=decg, b=false, sel=state2, out=C[6]);

    // FSM：状态转移

    // state0 在有 buttonFlag 时转入 state1
    And(a=state0, b=buttonFlag, out=condition0to1);
    And(a=state0, b=condition0to1, out=toState1);

    // state1 在车流周期未结束时保持
    Not(in=cycleComplete, out=notCycleComplete);
    And(a=state1, b=notCycleComplete, out=stayState1);
    Or(a=toState1, b=stayState1, out=nexts0temp);

    // state1 在 cycleComplete 时转入 state2
    And(a=state1, b=cycleComplete, out=toState2);

    // state2 在 timerDone 之前保持
    Not(in=timerDone, out=notTimerDone);
    And(a=state2, b=notTimerDone, out=stayState2);
    Or(a=toState2, b=stayState2, out=nexts1temp);

    // 断电时强制回到 state0 (s1s0=00)
    Mux(a=nexts0temp, b=true,  sel=notPowerOn, out=nexts0);
    Mux(a=nexts1temp, b=false, sel=notPowerOn, out=nexts1);
}
