CHIP Crossing {
    IN  PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    //============================
    // 状态寄存器：s1 s0
    // 00 : 无请求，正常运行
    // 01 : 已按键，等待两方向红灯
    // 10 : 行人倒计时状态
    //============================
    DFF(in=nextS0, out=s0);
    DFF(in=nextS1, out=s1);

    // 状态译码
    Not(in=s0, out=notS0);
    Not(in=s1, out=notS1);
    And(a=notS1, b=notS0, out=stateIdle);     // 00
    And(a=notS1, b=s0,    out=stateWait);     // 01
    And(a=s1,    b=notS0, out=stateCount);    // 10

    //============================
    // 调用十字路口主控制器
    //============================
    JunctionController(
        PowerOn=PowerOn,
        X[0]=xj0, X[1]=xj1, X[2]=xj2,
        Z[0]=zj0, Z[1]=zj1, Z[2]=zj2
    );

    // 计算 X、Z 是否为红灯（100）
    Not(in=xj0, out=notX0);
    Not(in=xj1, out=notX1);
    And(a=xj2, b=notX1, out=tmpX1);
    And(a=tmpX1, b=notX0, out=Xred);

    Not(in=zj0, out=notZ0);
    Not(in=zj1, out=notZ1);
    And(a=zj2, b=notZ1, out=tmpZ1);
    And(a=tmpZ1, b=notZ0, out=Zred);

    And(a=Xred, b=Zred, out=cycleDone);

    //============================
    // 行人倒计时计数器
    //============================
    Not(in=PowerOn, out=notPowerOn);
    Not(in=stateCount, out=notStateCount);

    Or(a=notPowerOn, b=notStateCount, out=timerReset);

    CounterDec(
        dec=stateCount,
        reset=timerReset,
        out[0]=cnt0,
        out[1]=cnt1,
        out[2]=cnt2,
        out[3]=cnt3
    );

    // 计数是否为 0（所有位为 0）
    Or(a=cnt0, b=cnt1, out=tBit01);
    Or(a=cnt2, b=cnt3, out=tBit23);
    Or(a=tBit01, b=tBit23, out=anyBitSet);
    Not(in=anyBitSet, out=timerDone);

    // 七段译码
    Decoder(
        in[0]=cnt0,
        in[1]=cnt1,
        in[2]=cnt2,
        in[3]=cnt3,
        a=segA,
        b=segB,
        c=segC,
        d=segD,
        e=segE,
        f=segF,
        g=segG
    );

    // 只有在倒计时时显示数字，否则熄灭
    Mux(a=segA, b=false, sel=stateCount, out=C[0]);
    Mux(a=segB, b=false, sel=stateCount, out=C[1]);
    Mux(a=segC, b=false, sel=stateCount, out=C[2]);
    Mux(a=segD, b=false, sel=stateCount, out=C[3]);
    Mux(a=segE, b=false, sel=stateCount, out=C[4]);
    Mux(a=segF, b=false, sel=stateCount, out=C[5]);
    Mux(a=segG, b=false, sel=stateCount, out=C[6]);

    //============================
    // 按钮锁存逻辑（ButtonPressed）
    //============================
    DFF(in=nextFlag, out=flag);

    // 按下按钮立即置位
    Or(a=Button, b=false, out=setFlag);

    // 倒计时结束时清零
    And(a=stateCount, b=timerDone, out=clearFlag);
    Not(in=clearFlag, out=notClearFlag);

    And(a=flag, b=notClearFlag, out=flagHold);
    Or(a=setFlag, b=flagHold, out=flagNextTemp);

    // PowerOn 为 0 时强制清零
    Mux(a=false, b=flagNextTemp, sel=PowerOn, out=nextFlag);

    // ButtonPressed 输出：是否有挂起或正在进行的请求
    Or(a=flag, b=false, out=ButtonPressed);

    //============================
    // 状态转移方程
    //============================

    // idle -> wait 条件：已有按钮请求
    And(a=stateIdle, b=flag, out=goWaitFromIdle);

    // wait -> wait：尚未到两个方向红灯
    Not(in=cycleDone, out=notCycleDone);
    And(a=stateWait, b=notCycleDone, out=stayWait);

    // wait -> count：两个方向红灯，开始倒计时
    And(a=stateWait, b=cycleDone, out=goCountFromWait);

    // count -> count：倒计时尚未结束
    Not(in=timerDone, out=notTimerDone);
    And(a=stateCount, b=notTimerDone, out=stayCount);

    // 组合得到 next 状态（PowerOn=1 时的正常 next）
    Or(a=goWaitFromIdle,   b=stayWait,   out=nextS0temp);
    Or(a=goCountFromWait,  b=stayCount,  out=nextS1temp);

    // 加入 PowerOn 复位：PowerOn=0 时强制到状态 00
    Mux(a=false, b=nextS0temp, sel=PowerOn, out=nextS0);
    Mux(a=false, b=nextS1temp, sel=PowerOn, out=nextS1);

    //============================
    // Wait 输出：有请求且不在倒计时阶段
    //============================
    And(a=flag, b=notStateCount, out=waitTemp);
    Or(a=waitTemp, b=false, out=Wait);

    //============================
    // 车辆信号灯输出
    // 倒计时时强制四个方向全红，其余时间按 JunctionController
    //============================
    Mux(a=xj0, b=false, sel=stateCount, out=X[0]);
    Mux(a=xj1, b=false, sel=stateCount, out=X[1]);
    Mux(a=xj2, b=true,  sel=stateCount, out=X[2]);

    Mux(a=zj0, b=false, sel=stateCount, out=Z[0]);
    Mux(a=zj1, b=false, sel=stateCount, out=Z[1]);
    Mux(a=zj2, b=true,  sel=stateCount, out=Z[2]);
}
