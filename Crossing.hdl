// ================================================
// Crossing Controller with Pedestrian Timer
// 修正内部总线使用问题
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    
    // --- 状态寄存器 (3位) ---
    // 状态编码: state2, state1, state0
    // 000: 双红灯 (初始状态)
    // 001: X红黄，Z红
    // 010: X绿，Z红
    // 011: X黄，Z红
    // 100: 双红灯 (X周期结束)
    // 101: Z红黄，X红
    // 110: Z绿，X红
    // 111: Z黄，X红
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 状态反相信号
    Not(in=state0, out=notState0);
    Not(in=state1, out=notState1);
    Not(in=state2, out=notState2);
    
    // --- 计时器模式寄存器 ---
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // --- 状态解码 ---
    // 状态000: 双红灯
    And(a=notState2, b=notState1, out=and0001);
    And(a=and0001, b=notState0, out=state000);
    
    // 状态001: X红黄
    And(a=notState2, b=notState1, out=and0011);
    And(a=and0011, b=state0, out=state001);
    
    // 状态010: X绿
    And(a=notState2, b=state1, out=and0101);
    And(a=and0101, b=notState0, out=state010);
    
    // 状态011: X黄
    And(a=notState2, b=state1, out=and0111);
    And(a=and0111, b=state0, out=state011);
    
    // 状态100: 双红灯
    And(a=state2, b=notState1, out=and1001);
    And(a=and1001, b=notState0, out=state100);
    
    // 状态101: Z红黄
    And(a=state2, b=notState1, out=and1011);
    And(a=and1011, b=state0, out=state101);
    
    // 状态110: Z绿
    And(a=state2, b=state1, out=and1101);
    And(a=and1101, b=notState0, out=state110);
    
    // 状态111: Z黄
    And(a=state2, b=state1, out=and1111);
    And(a=and1111, b=state0, out=state111);
    
    // --- 按钮检测和锁存 ---
    DFF(in=Button, out=buttonPrev);
    Not(in=buttonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=buttonRisingEdge);
    
    // 按钮锁存寄存器
    DFF(in=nextButtonLatched, out=buttonLatched);
    
    // --- 计时器模块 ---
    // 使用4位寄存器作为计时器，从9倒数到0
    DFF(in=nextTimer0, out=timer0);
    DFF(in=nextTimer1, out=timer1);
    DFF(in=nextTimer2, out=timer2);
    DFF(in=nextTimer3, out=timer3);
    
    // 检测计时器是否为0 (0000)
    Or(a=timer0, b=timer1, out=orTimer01);
    Or(a=timer2, b=timer3, out=orTimer23);
    Or(a=orTimer01, b=orTimer23, out=timerNotZero);
    Not(in=timerNotZero, out=timerZero);
    
    // --- 计时器控制逻辑 ---
    // 计时器递减使能：在计时器模式且计时器不为0时递减
    // 递减逻辑：timer - 1
    // 当timer=9(1001)时，减1后变为8(1000)
    
    // 计算减1后的值
    Not(in=timer0, out=notTimer0);
    Mux(a=timer0, b=notTimer0, sel=timerDec, out=timer0Dec);
    
    // 进位逻辑
    And(a=timerDec, b=timer0, out=carry0);
    Xor(a=timer1, b=carry0, out=timer1DecTemp);
    Mux(a=timer1, b=timer1DecTemp, sel=timerDec, out=timer1Dec);
    
    And(a=timer1, b=carry0, out=andCarry1);
    Or(a=carry0, b=andCarry1, out=carry1);
    
    Xor(a=timer2, b=carry1, out=timer2DecTemp);
    Mux(a=timer2, b=timer2DecTemp, sel=timerDec, out=timer2Dec);
    
    And(a=timer2, b=carry1, out=andCarry2);
    Or(a=carry1, b=andCarry2, out=carry2);
    
    Xor(a=timer3, b=carry2, out=timer3DecTemp);
    Mux(a=timer3, b=timer3DecTemp, sel=timerDec, out=timer3Dec);
    
    // 计时器递减使能：在计时器模式且计时器不为0时递减
    And(a=TimerMode, b=timerNotZero, out=timerDec);
    
    // 计时器复位：进入计时器模式时复位到9 (1001)
    // 进入计时器模式的条件：按钮已锁存且处于Z黄灯状态(111)
    And(a=buttonLatched, b=state111, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);
    
    // 应用复位和递减逻辑
    Mux(a=timer0Dec, b=true, sel=enterTimer, out=nextTimer0);   // 复位时timer0=1
    Mux(a=timer1Dec, b=false, sel=enterTimer, out=nextTimer1);  // 复位时timer1=0
    Mux(a=timer2Dec, b=false, sel=enterTimer, out=nextTimer2);  // 复位时timer2=0
    Mux(a=timer3Dec, b=true, sel=enterTimer, out=nextTimer3);   // 复位时timer3=1
    
    // --- 计时器模式控制逻辑 ---
    // 进入计时器模式：当满足条件时
    // 退出计时器模式：当计时器为0时
    And(a=TimerMode, b=timerZero, out=exitTimer);
    
    Or(a=enterTimer, b=TimerMode, out=stayOrEnter);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrEnter, b=notExit, out=nextTimerMode);
    
    // --- 按钮锁存逻辑 ---
    // 按钮按下时锁存，计时器模式结束时清除
    Or(a=buttonRisingEdge, b=buttonLatched, out=buttonLatchedOr);
    And(a=buttonLatchedOr, b=notTimerMode, out=nextButtonLatched);
    
    // --- 状态转移逻辑 ---
    // 正常状态转移序列：000->001->010->011->100->101->110->111->000
    
    // 状态0的下一状态位
    // 当状态为000,011,111时，下一状态的state0=1
    Or(a=state000, b=state011, out=orState01);
    Or(a=orState01, b=state111, out=orState02);
    And(a=orState02, b=PowerOn, out=nextState0Base);
    
    // 状态1的下一状态位
    // 当状态为001,010,101,110时，下一状态的state1=1
    Or(a=state001, b=state010, out=orState11);
    Or(a=state101, b=state110, out=orState12);
    Or(a=orState11, b=orState12, out=orState13);
    And(a=orState13, b=PowerOn, out=nextState1Base);
    
    // 状态2的下一状态位
    // 当状态为100,101,110,111时，下一状态的state2=1
    Or(a=state100, b=state101, out=orState21);
    Or(a=state110, b=state111, out=orState22);
    Or(a=orState21, b=orState22, out=orState23);
    And(a=orState23, b=PowerOn, out=nextState2Base);
    
    // 应用计时器模式：计时器模式下冻结状态机
    Mux(a=nextState0Base, b=state0, sel=TimerMode, out=nextState0);
    Mux(a=nextState1Base, b=state1, sel=TimerMode, out=nextState1);
    Mux(a=nextState2Base, b=state2, sel=TimerMode, out=nextState2);
    
    // --- 交通灯输出逻辑 ---
    // X灯: X[2]=红, X[1]=黄, X[0]=绿
    
    // X红灯亮当: 状态000,011,100,101,110,111,或计时器模式
    Or(a=state000, b=state011, out=xRedOr1);
    Or(a=state100, b=state101, out=xRedOr2);
    Or(a=state110, b=state111, out=xRedOr3);
    Or(a=xRedOr1, b=xRedOr2, out=xRedOr4);
    Or(a=xRedOr4, b=xRedOr3, out=xRedOr5);
    Or(a=xRedOr5, b=TimerMode, out=xRedOr6);
    And(a=xRedOr6, b=PowerOn, out=X[2]);
    
    // X黄灯亮当: 状态001或011
    Or(a=state001, b=state011, out=xAmberOr);
    And(a=xAmberOr, b=PowerOn, out=X[1]);
    
    // X绿灯亮当: 状态010
    And(a=state010, b=PowerOn, out=X[0]);
    
    // Z灯: Z[2]=红, Z[1]=黄, Z[0]=绿
    
    // Z红灯亮当: 状态000,001,010,011,100,111,或计时器模式
    Or(a=state000, b=state001, out=zRedOr1);
    Or(a=state010, b=state011, out=zRedOr2);
    Or(a=state100, b=state111, out=zRedOr3);
    Or(a=zRedOr1, b=zRedOr2, out=zRedOr4);
    Or(a=zRedOr4, b=zRedOr3, out=zRedOr5);
    Or(a=zRedOr5, b=TimerMode, out=zRedOr6);
    And(a=zRedOr6, b=PowerOn, out=Z[2]);
    
    // Z黄灯亮当: 状态101或111
    Or(a=state101, b=state111, out=zAmberOr);
    And(a=zAmberOr, b=PowerOn, out=Z[1]);
    
    // Z绿灯亮当: 状态110
    And(a=state110, b=PowerOn, out=Z[0]);
    
    // 计时器模式下强制双红灯
    Mux(a=X[2], b=true, sel=TimerMode, out=XredFinal);
    Mux(a=X[1], b=false, sel=TimerMode, out=XamberFinal);
    Mux(a=X[0], b=false, sel=TimerMode, out=XgreenFinal);
    
    Mux(a=Z[2], b=true, sel=TimerMode, out=ZredFinal);
    Mux(a=Z[1], b=false, sel=TimerMode, out=ZamberFinal);
    Mux(a=Z[0], b=false, sel=TimerMode, out=ZgreenFinal);
    
    // 应用计时器模式覆盖
    And(a=XredFinal, b=PowerOn, out=X[2]);
    And(a=XamberFinal, b=PowerOn, out=X[1]);
    And(a=XgreenFinal, b=PowerOn, out=X[0]);
    
    And(a=ZredFinal, b=PowerOn, out=Z[2]);
    And(a=ZamberFinal, b=PowerOn, out=Z[1]);
    And(a=ZgreenFinal, b=PowerOn, out=Z[0]);
    
    // --- Wait信号 ---
    // Wait=1表示交通灯在正常序列中，不能过街
    // Wait=0表示在计时器模式，可以过街
    Not(in=TimerMode, out=Wait);
    
    // --- ButtonPressed输出 ---
    And(a=buttonLatched, b=PowerOn, out=ButtonPressed);
    
    // --- 7段数码管输出 ---
    // 使用Decoder将4位计时器值转换为7段显示
    // 注意：Decoder的输出顺序为a,b,c,d,e,f,g
    // 但根据8.jpg，我们需要重新排序：C[6]=a, C[5]=e, C[4]=b, C[3]=c, C[2]=d, C[1]=f, C[0]=g
    
    // 创建4位总线连接Decoder
    Decoder(in[0]=timer0, in[1]=timer1, in[2]=timer2, in[3]=timer3,
            a=decA, b=decB, c=decC, d=decD, e=decE, f=decF, g=decG);
    
    // 仅当计时器模式时输出数码管信号
    And(a=decA, b=TimerMode, out=C[6]);  // a -> C[6]
    And(a=decE, b=TimerMode, out=C[5]);  // e -> C[5]
    And(a=decB, b=TimerMode, out=C[4]);  // b -> C[4]
    And(a=decC, b=TimerMode, out=C[3]);  // c -> C[3]
    And(a=decD, b=TimerMode, out=C[2]);  // d -> C[2]
    And(a=decF, b=TimerMode, out=C[1]);  // f -> C[1]
    And(a=decG, b=TimerMode, out=C[0]);  // g -> C[0]
}