CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    // ================================================
    // 1. 全局状态机（3位状态 S2S1S0，严格校验引脚格式）
    // ================================================
    // 状态寄存器（DFF仅in、out引脚，无多余参数）
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // 状态反相信号（Not芯片仅in、out引脚）
    Not(in=S2, out=notS2);
    Not(in=S1, out=notS1);
    Not(in=S0, out=notS0);
    
    // 步骤1：构造16位当前状态currentS（低3位=S2S1S0）
    // And芯片：a、b、out引脚显式声明，无多余参数
    And(a=S0, b=true, out=S01bit);
    And(a=S1, b=true, out=S11bit);
    And(a=S2, b=true, out=S21bit);
    
    // Mux16芯片：严格按a→b→sel→out顺序，引脚名无错写
    Mux16(a=16#0000, b=16#0001, sel=S01bit, out=bit0);  // 第0位：S0
    Mux16(a=bit0, b=16#0002, sel=S11bit, out=bit1);      // 第1位：S1
    Mux16(a=bit1, b=16#0004, sel=S21bit, out=currentS);  // 第2位：S2，构造完成
    
    // Inc16芯片：仅in、out引脚，无其他参数
    Inc16(in=currentS, out=incS);
    
    // 步骤2：提取incS低3位（Mux16+And组合，引脚格式正确）
    Mux16(a=16#0000, b=incS, sel=16#0001, out=incSbit0);
    And(a=incSbit0, b=16#0001, out=incS0);  // 提取第0位
    
    Mux16(a=16#0000, b=incS, sel=16#0002, out=incSbit1);
    And(a=incSbit1, b=16#0001, out=incS1);  // 提取第1位
    
    Mux16(a=16#0000, b=incS, sel=16#0004, out=incSbit2);
    And(a=incSbit2, b=16#0001, out=incS2);  // 提取第2位
    
    // PowerOn控制（Mux芯片：a、b、sel、out顺序严格）
    Mux(a=false, b=incS2, sel=PowerOn, out=nextS2raw);
    Mux(a=false, b=incS1, sel=PowerOn, out=nextS1raw);
    Mux(a=false, b=incS0, sel=PowerOn, out=nextS0raw);
    
    // 计时器模式锁定状态（Mux引脚格式正确）
    Mux(a=nextS2raw, b=S2, sel=TimerMode, out=nextS2);
    Mux(a=nextS1raw, b=S1, sel=TimerMode, out=nextS1);
    Mux(a=nextS0raw, b=S0, sel=TimerMode, out=nextS0);
    
    // ================================================
    // 2. 按钮检测与锁存（所有引脚显式声明，无隐含参数）
    // ================================================
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRising);  // 两输入And，引脚完整
    
    // SR触发器：严格按set→reset→q→qn顺序调用
    SRFF(set=ButtonRising, reset=TimerEnd, q=ButtonPressedReg, qn=notButtonPressed);
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);  // 引脚名无错写
    
    // ================================================
    // 3. 计时器控制（核心校验：所有部件引脚格式）
    // ================================================
    // 多输入And级联，引脚均为a、b、out
    And(a=S2, b=S1, out=S2S1);
    And(a=S2S1, b=S0, out=S2S1S0);
    And(a=S2S1S0, b=ButtonPressedReg, out=TimerStart);
    
    // 计时器模式寄存器（DFF引脚正确）
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // CounterDec：按load→dec→reset→out顺序调用，引脚名匹配定义
    CounterDec(load=TimerStart, dec=TimerMode, reset=PowerOn, out=TimerBus);
    
    // 提取TimerBus位（Mux16+And格式正确）
    Mux16(a=16#0000, b=TimerBus, sel=16#0001, out=T0bus);
    And(a=T0bus, b=16#0001, out=T0);
    
    Mux16(a=16#0000, b=TimerBus, sel=16#0002, out=T1bus);
    And(a=T1bus, b=16#0001, out=T1);
    
    Mux16(a=16#0000, b=TimerBus, sel=16#0004, out=T2bus);
    And(a=T2bus, b=16#0001, out=T2);
    
    Mux16(a=16#0000, b=TimerBus, sel=16#0008, out=T3bus);
    And(a=T3bus, b=16#0001, out=T3);
    
    // 计时器结束检测（Or芯片仅a、b、out引脚）
    Or(a=T0, b=T1, out=or01);
    Or(a=T2, b=T3, out=or23);
    Or(a=or01, b=or23, out=TimerNotZero);
    Not(in=TimerNotZero, out=TimerEnd);
    
    // 计时器模式控制（Or/And引脚正确）
    Or(a=TimerMode, b=TimerStart, out=stayTimer);
    And(a=stayTimer, b=TimerNotZero, out=nextTimerMode);
    
    // ================================================
    // 4. 状态解码（所有And/Or引脚显式声明）
    // ================================================
    And(a=notS2, b=notS1, out=notS2notS1);
    And(a=notS2notS1, b=notS0, out=state000);
    And(a=notS2notS1, b=S0, out=state001);
    
    And(a=notS2, b=S1, out=notS2S1);
    And(a=notS2S1, b=notS0, out=state010);
    And(a=notS2S1, b=S0, out=state011);
    
    And(a=S2, b=notS1, out=S2notS1);
    And(a=S2notS1, b=notS0, out=state100);
    And(a=S2notS1, b=S0, out=state101);
    
    And(a=S2, b=S1, out=S2S1);
    And(a=S2S1, b=notS0, out=state110);
    And(a=S2S1, b=S0, out=state111);
    
    // ================================================
    // 5. 交通灯输出（Mux引脚顺序严格）
    // ================================================
    Or(a=state000, b=state100, out=Xred1);
    Or(a=Xred1, b=S2, out=Xred);
    Or(a=state001, b=state011, out=Xamber);
    And(a=state010, b=true, out=Xgreen);
    
    Or(a=notS2, b=state100, out=Zred);
    Or(a=state101, b=state111, out=Zamber);
    And(a=state110, b=true, out=Zgreen);
    
    // 计时器模式强制RED（Mux引脚：a、b、sel、out）
    Mux(a=Xred, b=true, sel=TimerMode, out=X[2]);
    Mux(a=Xamber, b=false, sel=TimerMode, out=X[1]);
    Mux(a=Xgreen, b=false, sel=TimerMode, out=X[0]);
    Mux(a=Zred, b=true, sel=TimerMode, out=Z[2]);
    Mux(a=Zamber, b=false, sel=TimerMode, out=Z[1]);
    Mux(a=Zgreen, b=false, sel=TimerMode, out=Z[0]);
    
    // ================================================
    // 6. Wait信号与7段显示（无引脚格式错误）
    // ================================================
    Not(in=TimerMode, out=Wait);
    
    // 构造7段解码器输入总线（Mux16顺序正确）
    Mux16(a=16#0000, b=T0bus, sel=16#0001, out=decIn0);
    Mux16(a=decIn0, b=T1bus, sel=16#0002, out=decIn1);
    Mux16(a=decIn1, b=T2bus, sel=16#0004, out=decIn2);
    Mux16(a=decIn2, b=T3bus, sel=16#0008, out=decInBus);
    
    // Decoder7Seg：按in→a→b→c→d→e→f→g顺序调用
    Decoder7Seg(in=decInBus, a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG);
    
    // 段码输出（And引脚正确）
    And(a=segA, b=TimerMode, out=C[0]);
    And(a=segB, b=TimerMode, out=C[1]);
    And(a=segC, b=TimerMode, out=C[2]);
    And(a=segD, b=TimerMode, out=C[3]);
    And(a=segE, b=TimerMode, out=C[4]);
    And(a=segF, b=TimerMode, out=C[5]);
    And(a=segG, b=TimerMode, out=C[6]);
}

// ================================================
// 辅助芯片1：SR触发器（引脚定义与调用严格一致）
// ================================================
CHIP SRFF {
    IN set, reset;
    OUT q, qn;
    PARTS:
    Nand(a=set, b=qn, out=q);
    Nand(a=reset, b=q, out=qn);
}

// ================================================
// 辅助芯片2：4位十进制递减计数器（引脚无错写）
// ================================================
CHIP CounterDec {
    IN load, dec, reset;
    OUT out[4];
    PARTS:
    DFF(in=finalNext0, out=out[0]);
    DFF(in=finalNext1, out=out[1]);
    DFF(in=finalNext2, out=out[2]);
    DFF(in=finalNext3, out=out[3]);
    
    // 递减逻辑（所有芯片引脚正确）
    Mux16(a=16#0000, b=16#0001, sel=out[0], out=bit0cnt);
    Mux16(a=bit0cnt, b=16#0002, sel=out[1], out=bit1cnt);
    Mux16(a=bit1cnt, b=16#0004, sel=out[2], out=bit2cnt);
    Mux16(a=bit2cnt, b=16#0008, sel=out[3], out=currentCnt);
    
    Inc16(in=currentCnt, out=incTemp);
    Sub16(in=incTemp, sub=16#0001, out=decTemp);
    
    Mux16(a=16#0000, b=decTemp, sel=16#0001, out=decBit0);
    And(a=decBit0, b=16#0001, out=decNext0);
    Mux16(a=16#0000, b=decTemp, sel=16#0002, out=decBit1);
    And(a=decBit1, b=16#0001, out=decNext1);
    Mux16(a=16#0000, b=decTemp, sel=16#0004, out=decBit2);
    And(a=decBit2, b=16#0001, out=decNext2);
    Mux16(a=16#0000, b=decTemp, sel=16#0008, out=decBit3);
    And(a=decBit3, b=16#0001, out=decNext3);
    
    // 加载逻辑（Mux引脚正确）
    Mux(a=decNext0, b=true, sel=load, out=loadDec0);
    Mux(a=decNext1, b=false, sel=load, out=loadDec1);
    Mux(a=decNext2, b=false, sel=load, out=loadDec2);
    Mux(a=decNext3, b=true, sel=load, out=loadDec3);
    
    // 复位逻辑（Mux引脚正确）
    Mux(a=loadDec0, b=false, sel=reset, out=finalNext0);
    Mux(a=loadDec1, b=false, sel=reset, out=finalNext1);
    Mux(a=loadDec2, b=false, sel=reset, out=finalNext2);
    Mux(a=loadDec3, b=false, sel=reset, out=finalNext3);
}

// ================================================
// 辅助芯片3：7段解码器（引脚无错写，逻辑级联正确）
// ================================================
CHIP Decoder7Seg {
    IN in[4];
    OUT a, b, c, d, e, f, g;
    PARTS:
    // 提取输入位（Mux16+And格式正确）
    Mux16(a=16#0000, b=in, sel=16#0001, out=in0bus);
    And(a=in0bus, b=16#0001, out=in0);
    Mux16(a=16#0000, b=in, sel=16#0002, out=in1bus);
    And(a=in1bus, b=16#0001, out=in1);
    Mux16(a=16#0000, b=in, sel=16#0004, out=in2bus);
    And(a=in2bus, b=16#0001, out=in2);
    Mux16(a=16#0000, b=in, sel=16#0008, out=in3bus);
    And(a=in3bus, b=16#0001, out=in3);
    
    // 段码逻辑（两输入Or/And级联，引脚正确）
    Not(in=in3, out=notIn3);
    Not(in=in2, out=notIn2);
    Not(in=in1, out=notIn1);
    Not(in=in0, out=notIn0);
    
    Or(a=notIn3, b=in1, out=a1);
    Or(a=a1, b=in0, out=a);
    
    Or(a=notIn2, b=notIn1, out=b1);
    Or(a=b1, b=in0, out=b);
    
    Or(a=notIn1, b=in0, out=c);
    
    Or(a=notIn3, b=notIn2, out=d1);
    And(a=in1, b=notIn0, out=d2);
    Or(a=d1, b=d2, out=d);
    
    Or(a=notIn2, b=notIn0, out=e);
    
    Or(a=notIn3, b=in2, out=f1);
    Or(a=notIn1, b=notIn0, out=f2);
    And(a=f1, b=f2, out=f);
    
    Or(a=notIn3, b=in2, out=g1);
    Or(a=in1, b=notIn0, out=g2);
    And(a=g1, b=g2, out=g);
}