CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    // ================================================
    // 1. 全局状态机（3位状态 S2S1S0，避免子总线访问错误）
    // ================================================
    // 状态寄存器（每个状态位仅由一个 DFF 驱动，无重复）
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // 状态反相
    Not(in=S2, out=notS2);
    Not(in=S1, out=notS1);
    Not(in=S0, out=notS0);
    
    // 状态递增（模8）：通过 Mux16 提取低3位，无重复驱动
    And(a=S2, b=true, out=S21bit);
    And(a=S1, b=true, out=S11bit);
    And(a=S0, b=true, out=S01bit);
    Mux16(a=16#0000, b=16#0001, sel=S01bit, out=bit0);
    Mux16(a=bit0, b=16#0002, sel=S11bit, out=bit1);
    Mux16(a=bit1, b=16#0004, sel=S21bit, out=currentS);
    Inc16(in=currentS, out=incS);
    
    // 提取递增后的低3位（无重复驱动）
    Mux16(a=16#0000, b=incS, sel=16#0001, out=incSbit0);
    And(a=incSbit0, b=16#0001, out=incS0);
    Mux16(a=16#0000, b=incS, sel=16#0002, out=incSbit1);
    And(a=incSbit1, b=16#0001, out=incS1);
    Mux16(a=16#0000, b=incS, sel=16#0004, out=incSbit2);
    And(a=incSbit2, b=16#0001, out=incS2);
    
    // PowerOn 控制与计时器模式锁定
    Mux(a=false, b=incS2, sel=PowerOn, out=nextS2raw);
    Mux(a=false, b=incS1, sel=PowerOn, out=nextS1raw);
    Mux(a=false, b=incS0, sel=PowerOn, out=nextS0raw);
    Mux(a=nextS2raw, b=S2, sel=TimerMode, out=nextS2);
    Mux(a=nextS1raw, b=S1, sel=TimerMode, out=nextS1);
    Mux(a=nextS0raw, b=S0, sel=TimerMode, out=nextS0);
    
    // ================================================
    // 2. 按钮检测与锁存（无重复驱动）
    // ================================================
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRising);
    SRFF(set=ButtonRising, reset=TimerEnd, q=ButtonPressedReg, qn=notButtonPressed);
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
    
    // ================================================
    // 3. 计时器控制（修复 CounterDec 重复驱动问题）
    // ================================================
    And(a=S2, b=S1, c=S0, d=ButtonPressedReg, out=TimerStart);
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // 4位十进制计数器（无重复驱动，仅单个 DFF 驱动每个输出位）
    CounterDec(load=TimerStart, dec=TimerMode, reset=PowerOn, out=TimerBus);
    // 提取 TimerBus 位（无重复驱动）
    Mux16(a=16#0000, b=TimerBus, sel=16#0001, out=T0bus);
    And(a=T0bus, b=16#0001, out=T0);
    Mux16(a=16#0000, b=TimerBus, sel=16#0002, out=T1bus);
    And(a=T1bus, b=16#0001, out=T1);
    Mux16(a=16#0000, b=TimerBus, sel=16#0004, out=T2bus);
    And(a=T2bus, b=16#0001, out=T2);
    Mux16(a=16#0000, b=TimerBus, sel=16#0008, out=T3bus);
    And(a=T3bus, b=16#0001, out=T3);
    
    // 计时器结束检测
    Or(a=T0, b=T1, out=or01);
    Or(a=T2, b=T3, out=or23);
    Or(a=or01, b=or23, out=TimerNotZero);
    Not(in=TimerNotZero, out=TimerEnd);
    Or(a=TimerMode, b=TimerStart, out=stayTimer);
    And(a=stayTimer, b=TimerNotZero, out=nextTimerMode);
    
    // ================================================
    // 4. 交通灯输出（无重复驱动）
    // ================================================
    And(a=notS2, b=notS1, c=notS0, out=state000);
    And(a=notS2, b=notS1, c=S0, out=state001);
    And(a=notS2, b=S1, c=notS0, out=state010);
    And(a=notS2, b=S1, c=S0, out=state011);
    And(a=S2, b=notS1, c=notS0, out=state100);
    And(a=S2, b=notS1, c=S0, out=state101);
    And(a=S2, b=S1, c=notS0, out=state110);
    And(a=S2, b=S1, c=S0, out=state111);
    
    Or(a=state000, b=state100, c=S2, out=Xred);
    Or(a=state001, b=state011, out=Xamber);
    And(a=state010, b=true, out=Xgreen);
    Or(a=notS2, b=state100, out=Zred);
    Or(a=state101, b=state111, out=Zamber);
    And(a=state110, b=true, out=Zgreen);
    
    Mux(a=Xred, b=true, sel=TimerMode, out=X[2]);
    Mux(a=Xamber, b=false, sel=TimerMode, out=X[1]);
    Mux(a=Xgreen, b=false, sel=TimerMode, out=X[0]);
    Mux(a=Zred, b=true, sel=TimerMode, out=Z[2]);
    Mux(a=Zamber, b=false, sel=TimerMode, out=Z[1]);
    Mux(a=Zgreen, b=false, sel=TimerMode, out=Z[0]);
    
    // ================================================
    // 5. Wait 信号与7段显示（无重复驱动）
    // ================================================
    Not(in=TimerMode, out=Wait);
    // 构造7段解码器输入总线
    Mux16(a=16#0000, b=T0bus, sel=16#0001, out=decIn0);
    Mux16(a=decIn0, b=T1bus, sel=16#0002, out=decIn1);
    Mux16(a=decIn1, b=T2bus, sel=16#0004, out=decIn2);
    Mux16(a=decIn2, b=T3bus, sel=16#0008, out=decInBus);
    Decoder7Seg(in=decInBus, a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG);
    
    And(a=segA, b=TimerMode, out=C[0]);
    And(a=segB, b=TimerMode, out=C[1]);
    And(a=segC, b=TimerMode, out=C[2]);
    And(a=segD, b=TimerMode, out=C[3]);
    And(a=segE, b=TimerMode, out=C[4]);
    And(a=segF, b=TimerMode, out=C[5]);
    And(a=segG, b=TimerMode, out=C[6]);
}

// ================================================
// 辅助芯片1：SR触发器（无重复驱动）
// ================================================
CHIP SRFF {
    IN set, reset;
    OUT q, qn;
    PARTS:
    Nand(a=set, b=qn, out=q);
    Nand(a=reset, b=q, out=qn);
}

// ================================================
// 辅助芯片2：4位十进制递减计数器（核心修复！无重复驱动）
// 修复点：每个 out[X] 仅由一个 DFF 驱动，整合复位/加载/递减逻辑
// ================================================
CHIP CounterDec {
    IN load, dec, reset;
    OUT out[4]; // 4位总线：out[3]（T3）= 高位，out[0]（T0）= 低位
    PARTS:
    // 内部状态寄存器（每个输出位仅一个 DFF，无重复驱动）
    DFF(in=finalNext0, out=out[0]);
    DFF(in=finalNext1, out=out[1]);
    DFF(in=finalNext2, out=out[2]);
    DFF(in=finalNext3, out=out[3]);
    
    // 步骤1：计算递减后的值（dec=1时）
    // 构造当前计数的16位总线
    Mux16(a=16#0000, b=16#0001, sel=out[0], out=bit0);
    Mux16(a=bit0, b=16#0002, sel=out[1], out=bit1);
    Mux16(a=bit1, b=16#0004, sel=out[2], out=bit2);
    Mux16(a=bit2, b=16#0008, sel=out[3], out=currentCnt);
    // 递减1（currentCnt - 1）
    Inc16(in=currentCnt, out=incTemp); // +1 后减 16#0001 等价于 -1
    Sub16(in=incTemp, sub=16#0001, out=decTemp);
    // 提取递减后的低4位
    Mux16(a=16#0000, b=decTemp, sel=16#0001, out=decBit0);
    And(a=decBit0, b=16#0001, out=decNext0);
    Mux16(a=16#0000, b=decTemp, sel=16#0002, out=decBit1);
    And(a=decBit1, b=16#0001, out=decNext1);
    Mux16(a=16#0000, b=decTemp, sel=16#0004, out=decBit2);
    And(a=decBit2, b=16#0001, out=decNext2);
    Mux16(a=16#0000, b=decTemp, sel=16#0008, out=decBit3);
    And(a=decBit3, b=16#0001, out=decNext3);
    
    // 步骤2：加载逻辑（load=1时加载 9 → 1001）
    Mux(a=decNext0, b=true,  sel=load, out=loadDec0); // T0=1
    Mux(a=decNext1, b=false, sel=load, out=loadDec1); // T1=0
    Mux(a=decNext2, b=false, sel=load, out=loadDec2); // T2=0
    Mux(a=decNext3, b=true,  sel=load, out=loadDec3); // T3=1
    
    // 步骤3：复位逻辑（reset=1时强制输出 0000，优先级最高）
    Mux(a=loadDec0, b=false, sel=reset, out=finalNext0);
    Mux(a=loadDec1, b=false, sel=reset, out=finalNext1);
    Mux(a=loadDec2, b=false, sel=reset, out=finalNext2);
    Mux(a=loadDec3, b=false, sel=reset, out=finalNext3);
}

// ================================================
// 辅助芯片3：7段解码器（无重复驱动）
// ================================================
CHIP Decoder7Seg {
    IN in[4]; // 4位总线输入（T3T2T1T0）
    OUT a, b, c, d, e, f, g; // 共阴极段码（1=亮）
    PARTS:
    // 提取输入总线的4位（无重复驱动）
    Mux16(a=16#0000, b=in, sel=16#0001, out=in0bus);
    And(a=in0bus, b=16#0001, out=in0);
    Mux16(a=16#0000, b=in, sel=16#0002, out=in1bus);
    And(a=in1bus, b=16#0001, out=in1);
    Mux16(a=16#0000, b=in, sel=16#0004, out=in2bus);
    And(a=in2bus, b=16#0001, out=in2);
    Mux16(a=16#0000, b=in, sel=16#0008, out=in3bus);
    And(a=in3bus, b=16#0001, out=in3);
    
    // 段码逻辑（共阴极，匹配 9→0 显示）
    Or(a=not(in3), b=in1, c=in0, out=a);    // a段：0/2/3/5/6/7/8/9亮
    Or(a=not(in2), b=not(in1), c=in0, out=b); // b段：0/1/2/3/7/8/9亮
    Or(a=not(in1), b=in0, out=c);          // c段：0/1/3/4/5/6/8/9亮
    Or(a=not(in3), b=not(in2), c=in1, d=not(in0), out=d); // d段：0/2/3/5/6/8亮
    Or(a=not(in2), b=not(in0), out=e);     // e段：0/2/6/8亮
    Or(a=not(in3), b=in2, c=not(in1), d=not(in0), out=f); // f段：0/4/5/6/8/9亮
    Or(a=not(in3), b=in2, c=in1, d=not(in0), out=g); // g段：2/3/4/5/6/8/9亮
}