// ================================================
// Crossing Controller with Pedestrian Timer
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    
    // --- 状态寄存器 ---
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // 反相信号
    Not(in=S0, out=notS0);
    Not(in=S1, out=notS1);
    Not(in=S2, out=notS2);
    
    // --- 状态转移逻辑 ---
    Xor(a=S1, b=S0, out=xorS1S0);
    And(a=S1, b=S0, out=andS1S0);
    Xor(a=S2, b=andS1S0, out=xorS2);
    
    // 正常模式下的下一状态
    Mux(a=false, b=xorS2, sel=PowerOn, out=nextS2normal);
    Mux(a=false, b=xorS1S0, sel=PowerOn, out=nextS1normal);
    Mux(a=false, b=notS0, sel=PowerOn, out=nextS0normal);
    
    // --- 计时器模式控制 ---
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // --- 按钮检测逻辑 ---
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRisingEdge);
    
    // ButtonPressed寄存器
    DFF(in=nextBP, out=ButtonPressedReg);
    
    // --- 计时器模块 ---
    // 正确连接CounterDec的输出到4位总线TimerBus
    CounterDec(dec=TimerDec, reset=TimerReset, out=TimerBus);
    
    // 从4位总线中提取各个位（如果需要单独使用）
    // 注意：这里使用Or门将总线位连接到单比特信号，避免直接使用索引
    Or(a=TimerBus[0], b=false, out=Timer0);
    Or(a=TimerBus[1], b=false, out=Timer1);
    Or(a=TimerBus[2], b=false, out=Timer2);
    Or(a=TimerBus[3], b=false, out=Timer3);
    
    // 检查计时器是否为0（0000）
    Or(a=Timer0, b=Timer1, out=or01);
    Or(a=Timer2, b=Timer3, out=or23);
    Or(a=or01, b=or23, out=TimerNotZero);
    Not(in=TimerNotZero, out=TimerZero);
    
    // --- 检测Z周期完成 ---
    DFF(in=S2, out=S2prev);
    And(a=S2prev, b=notS2, out=S2falling);
    
    // 计时器启动条件：按钮已按下且Z周期完成
    And(a=ButtonPressedReg, b=S2falling, out=startTimerCond);
    And(a=startTimerCond, b=PowerOn, out=startTimer);
    
    // --- 按钮锁存逻辑 ---
    Or(a=ButtonRisingEdge, b=ButtonPressedReg, out=BPor);
    And(a=BPor, b=notTimerMode, out=BPand);
    Or(a=BPand, b=ButtonRisingEdge, out=nextBPtemp);
    And(a=nextBPtemp, b=PowerOn, out=nextBP);
    
    // --- 计时器模式控制逻辑 ---
    And(a=TimerMode, b=TimerZero, out=exitTimer);
    Or(a=TimerMode, b=startTimer, out=stayOrStart);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrStart, b=notExit, out=nextTimerMode);
    
    // 计时器递减使能：计时器模式且计时器不为0
    And(a=TimerMode, b=TimerNotZero, out=TimerDec);
    
    // 计时器复位：启动计时器时复位到9
    Mux(a=false, b=true, sel=startTimer, out=TimerReset);
    
    // --- 应用计时器模式到状态转移 ---
    Mux(a=nextS2normal, b=S2, sel=TimerMode, out=nextS2);
    Mux(a=nextS1normal, b=S1, sel=TimerMode, out=nextS1);
    Mux(a=nextS0normal, b=S0, sel=TimerMode, out=nextS0);
    
    // --- 交通灯输出逻辑 ---
    Mux(a=S1, b=false, sel=S2, out=xstate1);
    Mux(a=S0, b=false, sel=S2, out=xstate0);
    
    Mux(a=false, b=S1, sel=S2, out=zstate1);
    Mux(a=false, b=S0, sel=S2, out=zstate0);
    
    // X灯输出
    Not(in=xstate1, out=Xrednormal);
    Or(a=xstate0, b=false, out=Xambernormal);
    Not(in=xstate0, out=notxstate0);
    And(a=xstate1, b=notxstate0, out=Xgreennormal);
    
    // Z灯输出
    Not(in=zstate1, out=Zrednormal);
    Or(a=zstate0, b=false, out=Zambernormal);
    Not(in=zstate0, out=notzstate0);
    And(a=zstate1, b=notzstate0, out=Zgreennormal);
    
    // 应用计时器模式覆盖
    Mux(a=Xrednormal, b=true, sel=TimerMode, out=X[2]);
    Mux(a=Xambernormal, b=false, sel=TimerMode, out=X[1]);
    Mux(a=Xgreennormal, b=false, sel=TimerMode, out=X[0]);
    
    Mux(a=Zrednormal, b=true, sel=TimerMode, out=Z[2]);
    Mux(a=Zambernormal, b=false, sel=TimerMode, out=Z[1]);
    Mux(a=Zgreennormal, b=false, sel=TimerMode, out=Z[0]);
    
    // --- Wait信号 ---
    Not(in=TimerMode, out=Wait);
    
    // --- 7段数码管输出 ---
    // 直接将TimerBus（4位）传递给Decoder芯片
    Decoder(in=TimerBus, a=segA, b=segB, c=segC, d=segD, e=segE, f=segF, g=segG);
    
    // 仅当计时器模式时输出数码管信号
    And(a=segA, b=TimerMode, out=C[6]);
    And(a=segB, b=TimerMode, out=C[5]);
    And(a=segC, b=TimerMode, out=C[4]);
    And(a=segD, b=TimerMode, out=C[3]);
    And(a=segE, b=TimerMode, out=C[2]);
    And(a=segF, b=TimerMode, out=C[1]);
    And(a=segG, b=TimerMode, out=C[0]);
    
    // --- ButtonPressed输出 ---
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
}
