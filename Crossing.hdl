// ================================================
// Crossing Controller with Pedestrian Timer
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    PARTS:
    
    // --- 状态寄存器 (3位状态机) ---
    // S2: 0=X周期, 1=Z周期
    // S1,S0: 00=红, 01=红黄, 10=绿, 11=黄
    DFF(in=nextS2, out=S2);
    DFF(in=nextS1, out=S1);
    DFF(in=nextS0, out=S0);
    
    // 反相信号
    Not(in=S0, out=notS0);
    Not(in=S1, out=notS1);
    Not(in=S2, out=notS2);
    
    // --- 计时器模式控制 ---
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // --- 按钮检测逻辑 ---
    DFF(in=Button, out=ButtonPrev);
    Not(in=ButtonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=ButtonRisingEdge);
    
    // ButtonPressed寄存器
    DFF(in=nextBP, out=ButtonPressedReg);
    
    // --- 状态转移逻辑 (来自JunctionController) ---
    // 正常状态转移
    And(a=S1, b=S0, out=andS1S0);
    Xor(a=S2, b=andS1S0, out=xorS2);
    Xor(a=S1, b=S0, out=xorS1S0);
    
    // 应用PowerOn：当PowerOn为高时进行状态转移，否则保持状态
    Mux(a=S2, b=xorS2, sel=PowerOn, out=nextS2normal);
    Mux(a=S1, b=xorS1S0, sel=PowerOn, out=nextS1normal);
    Mux(a=S0, b=notS0, sel=PowerOn, out=nextS0normal);
    
    // --- 计时器模块 ---
    // 4位计数器，从9倒数到0
    // 使用CounterDec芯片，复位时加载9
    CounterDec(dec=TimerDec, reset=TimerReset, out[0]=Timer0, out[1]=Timer1, out[2]=Timer2, out[3]=Timer3);
    
    // 检查计时器是否为0 (0000)
    Or(a=Timer0, b=Timer1, out=or01);
    Or(a=Timer2, b=Timer3, out=or23);
    Or(a=or01, b=or23, out=TimerNotZero);
    Not(in=TimerNotZero, out=TimerZero);
    
    // --- 检测Z周期完成 ---
    // Z周期完成：当S2=1且状态为11(黄灯)时
    And(a=S2, b=S1, out=andS2S1);
    And(a=andS2S1, b=S0, out=ZYellowState);
    
    // 计时器启动条件：按钮已按下且处于Z黄灯状态
    And(a=ButtonPressedReg, b=ZYellowState, out=startTimerCond);
    And(a=startTimerCond, b=PowerOn, out=startTimer);
    
    // --- 按钮锁存逻辑 ---
    // 按钮按下后锁存，直到计时器结束
    Or(a=ButtonRisingEdge, b=ButtonPressedReg, out=BPor);
    And(a=BPor, b=notTimerMode, out=BPand);
    Or(a=BPand, b=ButtonRisingEdge, out=nextBPtemp);
    And(a=nextBPtemp, b=PowerOn, out=nextBP);
    
    // --- 计时器模式控制逻辑 ---
    And(a=TimerMode, b=TimerZero, out=exitTimer);
    Or(a=TimerMode, b=startTimer, out=stayOrStart);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrStart, b=notExit, out=nextTimerMode);
    
    // 计时器递减使能：计时器模式且计时器不为0
    And(a=TimerMode, b=TimerNotZero, out=TimerDec);
    
    // 计时器复位：启动计时器时复位到9
    Mux(a=false, b=true, sel=startTimer, out=TimerReset);
    
    // --- 应用计时器模式到状态转移 ---
    // 计时器模式下冻结状态机
    Mux(a=nextS2normal, b=S2, sel=TimerMode, out=nextS2);
    Mux(a=nextS1normal, b=S1, sel=TimerMode, out=nextS1);
    Mux(a=nextS0normal, b=S0, sel=TimerMode, out=nextS0);
    
    // --- 交通灯输出逻辑 ---
    // X灯控制：当S2=0时，X灯根据S1,S0变化；当S2=1时，X灯为红
    // Z灯控制：当S2=1时，Z灯根据S1,S0变化；当S2=0时，Z灯为红
    
    // X灯输出
    // X红：当S2=1（Z周期）或S1=0,S0=0（红状态）
    And(a=notS1, b=notS0, out=RedState);
    Or(a=S2, b=RedState, out=Xredtemp);
    Not(in=S2, out=notS2forX);
    And(a=notS2forX, b=S0, out=Xambertemp);
    And(a=notS2forX, b=S1, out=Xgreentemp1);
    Not(in=S0, out=notS0forXgreen);
    And(a=Xgreentemp1, b=notS0forXgreen, out=Xgreentemp2);
    
    // Z灯输出
    // Z红：当S2=0（X周期）或S1=0,S0=0（红状态）
    Or(a=notS2, b=RedState, out=Zredtemp);
    And(a=S2, b=S0, out=Zambertemp);
    And(a=S2, b=S1, out=Zgreentemp1);
    And(a=Zgreentemp1, b=notS0forXgreen, out=Zgreentemp2);
    
    // 应用计时器模式覆盖：计时器模式下，X和Z都是红灯
    Mux(a=Xredtemp, b=true, sel=TimerMode, out=X[2]);
    Mux(a=Xambertemp, b=false, sel=TimerMode, out=X[1]);
    Mux(a=Xgreentemp2, b=false, sel=TimerMode, out=X[0]);
    
    Mux(a=Zredtemp, b=true, sel=TimerMode, out=Z[2]);
    Mux(a=Zambertemp, b=false, sel=TimerMode, out=Z[1]);
    Mux(a=Zgreentemp2, b=false, sel=TimerMode, out=Z[0]);
    
    // --- Wait信号 ---
    // Wait=1表示交通灯在正常序列中，不能过街
    // Wait=0表示在计时模式，可以过街
    Not(in=TimerMode, out=Wait);
    
    // --- 7段数码管输出 ---
    // 重新设计一个简单的0-9解码器，避免使用Decoder芯片的问题
    // 根据8.jpg的段位顺序: C[6]=a, C[5]=b, C[4]=c, C[3]=d, C[2]=e, C[1]=f, C[0]=g
    
    // 数字0: 1111110
    // 数字1: 0110000  
    // 数字2: 1101101
    // 数字3: 1111001
    // 数字4: 0110011
    // 数字5: 1011011
    // 数字6: 1011111
    // 数字7: 1110000
    // 数字8: 1111111
    // 数字9: 1111011
    
    // 为每个数字创建检测逻辑
    And(a=notTimer3, b=notTimer2, out=digit0to3);
    And(a=digit0to3, b=notTimer1, out=digit0to1);
    And(a=digit0to1, b=notTimer0, out=digit0);
    And(a=digit0to1, b=Timer0, out=digit1);
    
    And(a=digit0to3, b=Timer1, out=digit2to3);
    And(a=digit2to3, b=notTimer0, out=digit2);
    And(a=digit2to3, b=Timer0, out=digit3);
    
    And(a=notTimer3, b=Timer2, out=digit4to7);
    And(a=digit4to7, b=notTimer1, out=digit4to5);
    And(a=digit4to5, b=notTimer0, out=digit4);
    And(a=digit4to5, b=Timer0, out=digit5);
    
    And(a=digit4to7, b=Timer1, out=digit6to7);
    And(a=digit6to7, b=notTimer0, out=digit6);
    And(a=digit6to7, b=Timer0, out=digit7);
    
    And(a=Timer3, b=notTimer2, out=digit8to9);
    And(a=digit8to9, b=notTimer1, out=digit8to9);
    And(a=digit8to9, b=notTimer0, out=digit8);
    And(a=digit8to9, b=Timer0, out=digit9);
    
    // 段a (C[6]): 在数字0,2,3,5,6,7,8,9中亮
    Or(a=digit0, b=digit2, out=ora1);
    Or(a=ora1, b=digit3, out=ora2);
    Or(a=ora2, b=digit5, out=ora3);
    Or(a=ora3, b=digit6, out=ora4);
    Or(a=ora4, b=digit7, out=ora5);
    Or(a=ora5, b=digit8, out=ora6);
    Or(a=ora6, b=digit9, out=segA);
    And(a=segA, b=TimerMode, out=C[6]);
    
    // 段b (C[5]): 在数字0,1,2,3,4,7,8,9中亮
    Or(a=digit0, b=digit1, out=orb1);
    Or(a=orb1, b=digit2, out=orb2);
    Or(a=orb2, b=digit3, out=orb3);
    Or(a=orb3, b=digit4, out=orb4);
    Or(a=orb4, b=digit7, out=orb5);
    Or(a=orb5, b=digit8, out=orb6);
    Or(a=orb6, b=digit9, out=segB);
    And(a=segB, b=TimerMode, out=C[5]);
    
    // 段c (C[4]): 在数字0,1,3,4,5,6,7,8,9中亮
    Or(a=digit0, b=digit1, out=orc1);
    Or(a=orc1, b=digit3, out=orc2);
    Or(a=orc2, b=digit4, out=orc3);
    Or(a=orc3, b=digit5, out=orc4);
    Or(a=orc4, b=digit6, out=orc5);
    Or(a=orc5, b=digit7, out=orc6);
    Or(a=orc6, b=digit8, out=orc7);
    Or(a=orc7, b=digit9, out=segC);
    And(a=segC, b=TimerMode, out=C[4]);
    
    // 段d (C[3]): 在数字0,2,3,5,6,8,9中亮
    Or(a=digit0, b=digit2, out=ord1);
    Or(a=ord1, b=digit3, out=ord2);
    Or(a=ord2, b=digit5, out=ord3);
    Or(a=ord3, b=digit6, out=ord4);
    Or(a=ord4, b=digit8, out=ord5);
    Or(a=ord5, b=digit9, out=segD);
    And(a=segD, b=TimerMode, out=C[3]);
    
    // 段e (C[2]): 在数字0,2,6,8中亮
    Or(a=digit0, b=digit2, out=ore1);
    Or(a=ore1, b=digit6, out=ore2);
    Or(a=ore2, b=digit8, out=segE);
    And(a=segE, b=TimerMode, out=C[2]);
    
    // 段f (C[1]): 在数字0,4,5,6,8,9中亮
    Or(a=digit0, b=digit4, out=orf1);
    Or(a=orf1, b=digit5, out=orf2);
    Or(a=orf2, b=digit6, out=orf3);
    Or(a=orf3, b=digit8, out=orf4);
    Or(a=orf4, b=digit9, out=segF);
    And(a=segF, b=TimerMode, out=C[1]);
    
    // 段g (C[0]): 在数字2,3,4,5,6,8,9中亮
    Or(a=digit2, b=digit3, out=org1);
    Or(a=org1, b=digit4, out=org2);
    Or(a=org2, b=digit5, out=org3);
    Or(a=org3, b=digit6, out=org4);
    Or(a=org4, b=digit8, out=org5);
    Or(a=org5, b=digit9, out=segG);
    And(a=segG, b=TimerMode, out=C[0]);
    
    // --- ButtonPressed输出 ---
    And(a=ButtonPressedReg, b=PowerOn, out=ButtonPressed);
}