// ================================================
// Crossing Controller with Pedestrian Timer
// 完全重设计版本 - 修正状态机和时序问题
// ================================================

CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];
    
    PARTS:
    
    // --- 状态寄存器 (3位) ---
    // 状态编码: 
    // 000: X红, Z红 (初始)
    // 001: X红黄, Z红
    // 010: X绿, Z红  
    // 011: X黄, Z红
    // 100: X红, Z红 (过渡状态)
    // 101: X红, Z红黄
    // 110: X红, Z绿
    // 111: X红, Z黄
    DFF(in=nextState0, out=state0);
    DFF(in=nextState1, out=state1);
    DFF(in=nextState2, out=state2);
    
    // 状态反相信号
    Not(in=state0, out=notState0);
    Not(in=state1, out=notState1);
    Not(in=state2, out=notState2);
    
    // --- 计时器模式寄存器 ---
    DFF(in=nextTimerMode, out=TimerMode);
    Not(in=TimerMode, out=notTimerMode);
    
    // --- 状态解码 ---
    // 状态000: X红, Z红
    And(a=notState2, b=notState1, out=and0001);
    And(a=and0001, b=notState0, out=state000);
    
    // 状态001: X红黄, Z红
    And(a=notState2, b=notState1, out=and0011);
    And(a=and0011, b=state0, out=state001);
    
    // 状态010: X绿, Z红
    And(a=notState2, b=state1, out=and0101);
    And(a=and0101, b=notState0, out=state010);
    
    // 状态011: X黄, Z红
    And(a=notState2, b=state1, out=and0111);
    And(a=and0111, b=state0, out=state011);
    
    // 状态100: X红, Z红
    And(a=state2, b=notState1, out=and1001);
    And(a=and1001, b=notState0, out=state100);
    
    // 状态101: X红, Z红黄
    And(a=state2, b=notState1, out=and1011);
    And(a=and1011, b=state0, out=state101);
    
    // 状态110: X红, Z绿
    And(a=state2, b=state1, out=and1101);
    And(a=and1101, b=notState0, out=state110);
    
    // 状态111: X红, Z黄
    And(a=state2, b=state1, out=and1111);
    And(a=and1111, b=state0, out=state111);
    
    // --- 按钮检测和锁存 ---
    DFF(in=Button, out=buttonPrev);
    Not(in=buttonPrev, out=notButtonPrev);
    And(a=Button, b=notButtonPrev, out=buttonRisingEdge);
    
    // 按钮锁存寄存器 - 按下后锁存，直到计时器模式结束
    DFF(in=nextButtonLatched, out=buttonLatched);
    
    // --- 计时器模块 ---
    // 使用4位寄存器作为计时器
    DFF(in=nextTimer0, out=timer0);
    DFF(in=nextTimer1, out=timer1);
    DFF(in=nextTimer2, out=timer2);
    DFF(in=nextTimer3, out=timer3);
    
    // 检测计时器是否为0 (0000)
    Or(a=timer0, b=timer1, out=orTimer01);
    Or(a=timer2, b=timer3, out=orTimer23);
    Or(a=orTimer01, b=orTimer23, out=timerNotZero);
    Not(in=timerNotZero, out=timerZero);
    
    // --- 计时器递减逻辑 ---
    // 计算timer - 1
    
    // 位0取反 (减1时位0翻转)
    Not(in=timer0, out=notTimer0);
    
    // 位1的进位
    And(a=timerDec, b=timer0, out=carry0);
    Xor(a=timer1, b=carry0, out=timer1Xor);
    
    // 位2的进位
    And(a=timer1, b=carry0, out=and11);
    Or(a=carry0, b=and11, out=carry1);
    Xor(a=timer2, b=carry1, out=timer2Xor);
    
    // 位3的进位
    And(a=timer2, b=carry1, out=and21);
    Or(a=carry1, b=and21, out=carry2);
    Xor(a=timer3, b=carry2, out=timer3Xor);
    
    // 计时器递减使能
    And(a=TimerMode, b=timerNotZero, out=timerDec);
    
    // 选择递减后的值或当前值
    Mux(a=timer0, b=notTimer0, sel=timerDec, out=timer0Dec);
    Mux(a=timer1, b=timer1Xor, sel=timerDec, out=timer1Dec);
    Mux(a=timer2, b=timer2Xor, sel=timerDec, out=timer2Dec);
    Mux(a=timer3, b=timer3Xor, sel=timerDec, out=timer3Dec);
    
    // --- 计时器模式控制 ---
    // 进入计时器模式的条件：按钮已锁存且处于Z黄灯状态(111)
    And(a=buttonLatched, b=state111, out=enterTimerCond);
    And(a=enterTimerCond, b=PowerOn, out=enterTimer);
    
    // 退出计时器模式的条件：计时器为0
    And(a=TimerMode, b=timerZero, out=exitTimer);
    
    // 计时器模式下一状态
    Or(a=enterTimer, b=TimerMode, out=stayOrEnter);
    Not(in=exitTimer, out=notExit);
    And(a=stayOrEnter, b=notExit, out=nextTimerMode);
    
    // 应用计时器复位：进入时设置为9 (1001)
    Mux(a=timer0Dec, b=true, sel=enterTimer, out=nextTimer0);
    Mux(a=timer1Dec, b=false, sel=enterTimer, out=nextTimer1);
    Mux(a=timer2Dec, b=false, sel=enterTimer, out=nextTimer2);
    Mux(a=timer3Dec, b=true, sel=enterTimer, out=nextTimer3);
    
    // --- 按钮锁存逻辑 ---
    // 按钮按下时锁存，计时器模式结束时清除
    Or(a=buttonRisingEdge, b=buttonLatched, out=buttonLatchedOr);
    And(a=buttonLatchedOr, b=notTimerMode, out=nextButtonLatched);
    
    // --- 状态转移逻辑 ---
    // 正常序列：000->001->010->011->100->101->110->111->000
    
    // 状态0的下一状态位
    // 当状态为000,011,111时，下一状态的state0=1
    Or(a=state000, b=state011, out=orState01);
    Or(a=orState01, b=state111, out=orState02);
    And(a=orState02, b=PowerOn, out=nextState0Base);
    
    // 状态1的下一状态位
    // 当状态为001,010,101,110时，下一状态的state1=1
    Or(a=state001, b=state010, out=orState11);
    Or(a=state101, b=state110, out=orState12);
    Or(a=orState11, b=orState12, out=orState13);
    And(a=orState13, b=PowerOn, out=nextState1Base);
    
    // 状态2的下一状态位
    // 当状态为100,101,110,111时，下一状态的state2=1
    Or(a=state100, b=state101, out=orState21);
    Or(a=state110, b=state111, out=orState22);
    Or(a=orState21, b=orState22, out=orState23);
    And(a=orState23, b=PowerOn, out=nextState2Base);
    
    // 应用计时器模式：计时器模式下状态机冻结
    Mux(a=nextState0Base, b=state0, sel=TimerMode, out=nextState0);
    Mux(a=nextState1Base, b=state1, sel=TimerMode, out=nextState1);
    Mux(a=nextState2Base, b=state2, sel=TimerMode, out=nextState2);
    
    // --- 交通灯输出逻辑 ---
    // X灯: X[2]=红, X[1]=黄, X[0]=绿
    
    // X红灯亮当: 状态000,011,100,101,110,111 或计时器模式
    Or(a=state000, b=state011, out=xRedOr1);
    Or(a=state100, b=state101, out=xRedOr2);
    Or(a=state110, b=state111, out=xRedOr3);
    Or(a=xRedOr1, b=xRedOr2, out=xRedOr4);
    Or(a=xRedOr4, b=xRedOr3, out=xRedOr5);
    Or(a=xRedOr5, b=TimerMode, out=xRedOr6);
    And(a=xRedOr6, b=PowerOn, out=X[2]);
    
    // X黄灯亮当: 状态001或010 (红黄或黄)
    // 注意: 状态001是红黄，状态010是绿，这里应该只是001和011
    // 修正: X黄灯应该是状态001(红黄)和状态011(黄)
    Or(a=state001, b=state011, out=xAmberOr);
    And(a=xAmberOr, b=PowerOn, out=X[1]);
    
    // X绿灯亮当: 状态010
    And(a=state010, b=PowerOn, out=X[0]);
    
    // Z灯: Z[2]=红, Z[1]=黄, Z[0]=绿
    
    // Z红灯亮当: 状态000,001,010,011,100,111 或计时器模式
    Or(a=state000, b=state001, out=zRedOr1);
    Or(a=state010, b=state011, out=zRedOr2);
    Or(a=state100, b=state111, out=zRedOr3);
    Or(a=zRedOr1, b=zRedOr2, out=zRedOr4);
    Or(a=zRedOr4, b=zRedOr3, out=zRedOr5);
    Or(a=zRedOr5, b=TimerMode, out=zRedOr6);
    And(a=zRedOr6, b=PowerOn, out=Z[2]);
    
    // Z黄灯亮当: 状态101或111 (红黄或黄)
    // 修正: Z黄灯应该是状态101(红黄)和状态111(黄)
    Or(a=state101, b=state111, out=zAmberOr);
    And(a=zAmberOr, b=PowerOn, out=Z[1]);
    
    // Z绿灯亮当: 状态110
    And(a=state110, b=PowerOn, out=Z[0]);
    
    // 计时器模式下强制双红灯
    Mux(a=X[2], b=true, sel=TimerMode, out=XredFinal);
    Mux(a=X[1], b=false, sel=TimerMode, out=XamberFinal);
    Mux(a=X[0], b=false, sel=TimerMode, out=XgreenFinal);
    
    Mux(a=Z[2], b=true, sel=TimerMode, out=ZredFinal);
    Mux(a=Z[1], b=false, sel=TimerMode, out=ZamberFinal);
    Mux(a=Z[0], b=false, sel=TimerMode, out=ZgreenFinal);
    
    // 应用计时器模式覆盖
    And(a=XredFinal, b=PowerOn, out=X[2]);
    And(a=XamberFinal, b=PowerOn, out=X[1]);
    And(a=XgreenFinal, b=PowerOn, out=X[0]);
    
    And(a=ZredFinal, b=PowerOn, out=Z[2]);
    And(a=ZamberFinal, b=PowerOn, out=Z[1]);
    And(a=ZgreenFinal, b=PowerOn, out=Z[0]);
    
    // --- Wait信号 ---
    // Wait=1表示交通灯在正常序列中，不能过街
    // Wait=0表示在计时器模式，可以过街
    Not(in=TimerMode, out=Wait);
    
    // --- ButtonPressed输出 ---
    And(a=buttonLatched, b=PowerOn, out=ButtonPressed);
    
    // --- 7段数码管输出 ---
    // 使用Decoder将4位计时器值转换为7段显示
    Decoder(in[0]=timer0, in[1]=timer1, in[2]=timer2, in[3]=timer3,
            a=decA, b=decB, c=decC, d=decD, e=decE, f=decF, g=decG);
    
    // 重新排序：根据8.jpg的映射
    // C[6]=a (下横), C[5]=e (上横), C[4]=b (中横), 
    // C[3]=c (右下竖), C[2]=d (左上竖), C[1]=f (右上竖), C[0]=g (左下竖)
    
    // 仅当计时器模式时输出数码管信号
    And(a=decA, b=TimerMode, out=C[6]);  // a -> C[6]
    And(a=decE, b=TimerMode, out=C[5]);  // e -> C[5]
    And(a=decB, b=TimerMode, out=C[4]);  // b -> C[4]
    And(a=decC, b=TimerMode, out=C[3]);  // c -> C[3]
    And(a=decD, b=TimerMode, out=C[2]);  // d -> C[2]
    And(a=decF, b=TimerMode, out=C[1]);  // f -> C[1]
    And(a=decG, b=TimerMode, out=C[0]);  // g -> C[0]
}